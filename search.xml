<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>R数据科学 R for data sciences</title>
      <link href="/2020/09/07/R-4ds/"/>
      <url>/2020/09/07/R-4ds/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><code>reprex</code>包：创建简单的可重现实例。检查问题所在。</li></ul><h2 id="一-使用ggplot2进行数据可视化"><a href="#一-使用ggplot2进行数据可视化" class="headerlink" title="一 使用ggplot2进行数据可视化"></a>一 使用ggplot2进行数据可视化</h2><ol><li>坐标系<code>ggplot()</code>，在此函数种添加的映射会作为全局变量应用到图中的每个几何对象种。</li><li>图层<code>geom_point</code>点图层</li><li><strong>映射数据为图形属性</strong> <code>mapping=aes()</code>，要想将图形属性映射为变量，需要在函数aes()中将图形属性的名称和变量的名称关联起来。</li><li>标度变化：将变量（数据）分配唯一的图形属性水平。</li><li>手动设置图形属性，此是在geom_point()层面。此时，<strong>这个颜色是不会传达变量数据的信息。</strong></li><li>分层<strong>facet</strong>：<code>facet_grid()</code>可以通过两个变量对图分层`facet_grid(drv<del>cyl)或(.</del>cyl)</li><li><strong>分组</strong><code>aes(group)</code>此种按照图形属性的分组不用添加图例，也不用为几何对象添加区分特征</li><li><strong>统计变换</strong>：绘图时用来计算新数据的算法称为stat(statistical transformation,统计变化)。比如对于<code>geom_bar()</code>默认是只对一个数据x映射，其统计变化后生成数据x种的每个值的count数。<ul><li>每个几何对象函数都有一个默认的统计变换，每个统计变换函数都有一个默认的几何对象。</li><li><strong>如需要展示二维柱状图数据，geom_bar(mapping=aes(x=a,y=b),stat=”identity “)</strong></li></ul></li></ol><p><img src="https://gitee.com/tianpeng__wang/image/raw/master/tianpeng_pic/20200826203108.png" alt=""></p><ol start="9"><li><strong>图形属性/位置调整</strong>：<ul><li><code>color</code>,<code>fill</code></li><li>位置调整参数<code>position</code>有三个选项：”identity”,”fill”,”dodge”</li><li><code>position=&quot;dodge&quot;</code>参数可分组显示数据，将每组种的条形依次并列放置，可以轻松比较每个条形表示的具体数值。<br><img src="https://gitee.com/tianpeng__wang/image/raw/master/tianpeng_pic/20200826204311.png" alt=""></li><li>数据的聚集模式无法很好确定，因为存在数据的<strong>过绘制</strong>问题（很多彼此十分近的点重叠了）<code>position=&quot;jitter&quot;</code>对于geom_position()函数来说，<strong>jitter</strong>的位置方式为抖动会排除过绘制问题<code>ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy), position = &quot;jitter&quot;)</code></li></ul></li><li><strong>坐标系</strong>：<ul><li><code>coord_flip()</code>函数可以交换x轴和y轴<br><img src="https://gitee.com/tianpeng__wang/image/raw/master/tianpeng_pic/20200826204609.png" alt=""></li><li><code>labs()</code>：modify axis, legend, and plot labels.</li><li><code>coord_polar()</code>极坐标<img src="https://gitee.com/tianpeng__wang/image/raw/master/tianpeng_pic/20200826204834.png" alt=""></li></ul></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">mpg</span><br><span class="line">str(mpg)</span><br><span class="line">data&lt;- mpg</span><br><span class="line">?mpg ##查看mpg数据的说明</span><br><span class="line">ggplot(data = mpg)+geom_point(aes(x=displ,y=hwy))</span><br><span class="line"></span><br><span class="line">ggplot(mpg)+geom_point(mapping = aes(x=displ,y=hwy,color=class),color=&quot;#EF5C4E&quot;,shape=19)</span><br><span class="line">ggplot(mpg)+geom_point(mapping = aes(x=displ,y=hwy),color=&quot;#EF5C4E&quot;,shape=19)</span><br><span class="line">ggplot(mpg)+geom_point(mapping = aes(x=displ,y=hwy,stroke=displ),shape=19)</span><br><span class="line">## 添加两个图层：geom_point,geom_smooth()</span><br><span class="line">ggplot(mpg)+geom_point(mapping = aes(x=displ,y=hwy,color=drv))+geom_smooth(mapping = aes(x=displ,y=hwy,linetype=drv,color=drv))</span><br><span class="line"># 添加分组</span><br><span class="line">ggplot(data = mpg)+geom_smooth(mapping = aes(x=displ,y=hwy,group=drv))</span><br><span class="line">ggplot(data = mpg)+geom_smooth(mapping = aes(x=displ,y=hwy,color=drv),show.legend = F) ## 图例 show.legend=F</span><br><span class="line"></span><br><span class="line">## 在不同的图层中添加指定不同的数据</span><br><span class="line">## data=filter(mpg,class==&quot;suv&quot;), se=F，表示去除f波动的范围。</span><br><span class="line">ggplot(data = mpg,mapping = aes(x=displ,y=hwy))+geom_point(mapping = aes(color=class))+geom_smooth(data = filter(.data = mpg,class==&quot;suv&quot;))</span><br><span class="line"></span><br><span class="line">##exercices</span><br><span class="line">ggplot(data = mpg,mapping = aes(x=displ,y=hwy))+geom_point()+geom_smooth(se = F)</span><br><span class="line">ggplot(data = mpg,mapping = aes(x=displ,y=hwy))+geom_point()+geom_smooth(se = F,mapping = aes(group=drv))</span><br><span class="line">ggplot(data = mpg,mapping = aes(x=displ,y=hwy,color=drv))+geom_point()+geom_smooth(se = F)</span><br><span class="line">ggplot(data = mpg,mapping = aes(x=displ,y=hwy))+geom_point(mapping = aes(color=drv))+geom_smooth(se = F)</span><br><span class="line">ggplot(data = mpg,mapping = aes(x=displ,y=hwy))+geom_point(mapping = aes(color=drv))+geom_smooth(mapping = aes(linetype=drv),se = F)</span><br><span class="line">ggplot(data = mpg,mapping = aes(x=displ,y=hwy))+geom_point(mapping = aes(color=drv))</span><br><span class="line"></span><br><span class="line">### 统计变换</span><br><span class="line">ggplot(data = mpg,mapping = aes(x=displ,y=hwy))+geom_point()+geom_smooth(se = F)</span><br><span class="line">ggplot(data=diamonds)+stat_summary(mapping = aes(x=cut,y=depth))</span><br><span class="line">ggplot(data=diamonds)+geom_boxplot(mapping = aes(x=cut,y=price))</span><br><span class="line">ggplot(data=diamonds)+geom_bar(mapping = aes(x=cut))</span><br><span class="line">ggplot(data=diamonds)+geom_bar(mapping = aes(x=cut,y=..prop..),group=2)</span><br><span class="line"></span><br><span class="line">### 图形调整,位置调整</span><br><span class="line">ggplot(diamonds)+geom_bar(mapping = aes(x=cut,fill=cut),color=&quot;black&quot;)+scale_fill_brewer(palette = &quot;Set3&quot;)</span><br><span class="line">ggplot(diamonds)+geom_bar(mapping = aes(x=cut,fill=clarity))+scale_fill_brewer(palette = &quot;Set2&quot;)</span><br><span class="line">ggplot(diamonds)+geom_bar(mapping=aes(x=cut,color=clarity),position = &quot;dodge&quot;)+scale_fill_brewer(palette = &quot;Set2&quot;)</span><br><span class="line">ggplot(mpg)+geom_point(mapping = aes(x=displ,y=hwy),position = &quot;jitter&quot;)</span><br><span class="line">##exercises</span><br><span class="line">ggplot(mpg,mapping = aes(x=cty,y=hwy))+geom_point(position = &quot;jitter&quot;)+geom_smooth(color=&quot;black&quot;)</span><br><span class="line">ggplot(mpg,mapping = aes(x=cty,y=hwy))+geom_jitter()</span><br><span class="line">ggplot(mpg,mapping = aes(x=cty,y=hwy))+geom_count()</span><br><span class="line">ggplot(mpg)+geom_boxplot(mapping = aes(x=manufacturer,y=hwy),position = &quot;identity&quot;)</span><br><span class="line">?geom_boxplot</span><br><span class="line"></span><br><span class="line">###1.9 坐标系</span><br><span class="line">ggplot(mpg,mapping = aes(x=class,y=hwy))+geom_boxplot()+coord_flip()</span><br><span class="line">nz &lt;- map_data(&quot;nz&quot;)</span><br><span class="line">?map_data</span><br><span class="line">ggplot(data=diamonds)+geom_bar(mapping = aes(x=cut,fill=cut),show.legend = FALSE)+theme(aspect.ratio = 1)+labs()</span><br><span class="line">bar+scale_color_brewer(palette = &quot;Set2&quot;)</span><br><span class="line">bar+coord_flip()</span><br><span class="line">bar+coord_polar()</span><br></pre></td></tr></table></figure><h2 id="二-工作流：基础-Workflow：basics"><a href="#二-工作流：基础-Workflow：basics" class="headerlink" title="二 工作流：基础 Workflow：basics"></a>二 工作流：基础 Workflow：basics</h2><ol><li>赋值：小技巧，<strong>alt+减号</strong>会自动输入赋值符号&lt;- 并在前后加空格</li><li>对象：用<strong>snake_case命名法</strong>小写字母，以_分割。</li><li>Rstudio中快捷查看命令：Alt+Shift+K</li></ol><h2 id="三-使用dplyr进行数据转换"><a href="#三-使用dplyr进行数据转换" class="headerlink" title="三 使用dplyr进行数据转换"></a>三 使用dplyr进行数据转换</h2><ol><li>特殊的data.frame<code>tibble</code>。</li><li>变量variable类型：<ul><li>int：</li><li>dbl(num的一种？):双精度浮点数变量，或称实数。</li><li>chr：字符向量/字符串</li><li>dttm：日期+时间</li><li>lgl：逻辑型变量</li><li>fctr（factor）：因子</li><li>date：日期型变量</li></ul></li><li>基础函数：<code>filter()</code>,<code>arrange()</code>,<code>select()</code>,<code>mutate()</code>,<code>summarize()</code>,<code>group_by()</code></li><li>使用<code>filter()</code>筛选:<ul><li>filter(flights, arr_delay&lt;=10).</li><li>比较运算符 ==, !=, &lt;=</li><li>逻辑运算符 x &amp; !y, x|y, xor(x,y)<br><img src="https://gitee.com/tianpeng__wang/image/raw/master/tianpeng_pic/20200826210637.png" alt=""></li><li>缺失值 NA, is.na()</li><li><code>%in%</code> ：<code>month %in% c(11, 12)</code></li><li><code>distinct(iris, Species)</code>删除重复行</li><li><code>sample_n()</code>任意挑选行</li><li><code>slice(irsi,10:15)</code></li></ul></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">## filter()</span><br><span class="line">(jan1 &lt;- filter(flights,month==1,day==1))</span><br><span class="line">(dec25 &lt;- filter(flights,month==12,day==25))</span><br><span class="line">filter(flights,month&gt;=11)</span><br><span class="line">(nov_dec &lt;- filter(flights,month %in% c(11,12)))</span><br><span class="line">filter(flights,!(arr_delay&lt;=120 | dep_delay&lt;=120))</span><br><span class="line">NA&gt;=10</span><br><span class="line">x &lt;- NA</span><br><span class="line">is.na(x)</span><br><span class="line">df &lt;- tibble(x=c(1,NA,2))</span><br><span class="line">filter(df,x&gt;1)</span><br><span class="line">filter(df,is.na(x)|x&gt;1)</span><br><span class="line">### exercise</span><br><span class="line">filter(flights,carrier %in% c(&quot;UA&quot;,&quot;AA&quot;,&quot;DL&quot;))</span><br><span class="line">filter(flights,month %in% c(7,8,9))</span><br><span class="line">filter(flights,arr_delay&gt;120 &amp; dep_delay==0)</span><br><span class="line">filter(flights,dep_delay &gt;= 60 &amp; (dep_delay-arr_delay&gt;=30)) </span><br><span class="line">filter(flights,dep_time ==2400| dep_time&lt;=600)</span><br><span class="line">filter(flights,is.na(dep_time))</span><br></pre></td></tr></table></figure><ol start="5"><li><p>使用 <code>arrange()</code>按照列(variable)的值values进行排序</p><ul><li><code>desc</code>倒序</li><li>缺失值排在最后，若想提前可<code>desc(is.na())</code></li><li><code>top_n(10,wind)</code>选择wind变量从大到小的前10个。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># arrange()</span><br><span class="line">arrange(flights,desc(dep_delay,arr_delay)) #降序排列</span><br><span class="line">arrange(flights,desc(is.na(dep_delay),arr_delay)) ##将NA值排列到前面</span><br><span class="line"></span><br><span class="line">### find the 5 cars with highest hp without ordering them</span><br><span class="line">mtcars %&gt;% top_n(5, hp)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>使用<code>select()</code>选择列：（数据集会有成千上万个变量，select选出变量的子集）</p><ul><li>选出year~day之间的列：<code>select(flights, year:day)</code></li><li>选出排除year~day列：<code>select(flights,-(year:dat))</code></li><li><strong>匹配变量中的名称</strong>： <code>matches(&quot;&quot;)</code>, <code>contains(&quot;ijk&quot;)</code></li><li>匹配变量中的开头，结尾名称<code>starts_with(&quot;&quot;)</code>, <code>ends_with()</code>,</li><li><code>rename()</code><strong>对列变量重新命名</strong></li><li><code>everything()</code><strong>辅助函数来将某几列提前</strong>。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">## select()</span><br><span class="line">select(flights,year:day)</span><br><span class="line">select(flights,-(year:day)) ## 不包括year:day</span><br><span class="line">select(flights,starts_with(&quot;s&quot;))</span><br><span class="line">select(flights,ends_with(&quot;e&quot;))</span><br><span class="line">select(flights,matches(&quot;time&quot;))</span><br><span class="line">select(flights,matches(&quot;(.)\\1&quot;))</span><br><span class="line"></span><br><span class="line">rename(flights,tail_num=tailnum) ##对变量进行重命名</span><br><span class="line">select(flights,-(month:day),everything()) ## 结合everything()辅助函数 对某几列提前, 置后同理</span><br><span class="line">select(flights, hour:time_hour,everything())</span><br><span class="line">###exercise</span><br><span class="line">select(flights,year,year,year)</span><br><span class="line">select(flights,one_of(c(&quot;year&quot;,&quot;month&quot;,&quot;day&quot;,&quot;dep_delay&quot;)))</span><br><span class="line">select(flights,contains(&quot;TIME&quot;))</span><br></pre></td></tr></table></figure></li></ul></li><li><p>使用<code>mutate()</code>添加新的列/变量：</p><ul><li><code>mutate()</code> 新列添加到已有列的后面；</li><li><code>transmute</code> 只保留新的变量。</li><li>常用的运算符号：<strong>求整%/%</strong>，求余%%，<strong>偏移函数lead(), lag()</strong>，累加和和滚动聚合，逻辑比较，排秩。</li><li>==rename()== 可对变量名称进行重新命名。</li><li>==rename_all(~str_replace(., “”, “”))== 可以根据正则匹配进行改名。</li><li>==mutate_all()== 可对所有observations进行修改。</li><li>==case_when()== 根据已有的columns创建新的discrete variables。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"># mutate() 在tibble后 添加新变量/列</span><br><span class="line">flights_sml &lt;- select(flights,year:day,matches(&quot;_delay&quot;),distance,air_time)</span><br><span class="line">flights_sml</span><br><span class="line">mutate(flights_sml,flying_delay=arr_delay-dep_delay,speed=distance/air_time * 60 )</span><br><span class="line">flights_sml</span><br><span class="line">transmute(flights,gain=arr_delay-dep_delay,hour=air_time/60,gain_per_hour=gain/hour)</span><br><span class="line"></span><br><span class="line">mutate(flights,dep_time=((dep_time%/%100 * 60)+(dep_time%%100))) ## 会直接在flights中改动dep_time</span><br><span class="line">flights</span><br><span class="line">transmute(flights,air_time,duration=(arr_time-dep_time),arr_delay)</span><br><span class="line">1:3+1:10</span><br><span class="line">1:10+1:3</span><br><span class="line">1:10</span><br><span class="line">?cos</span><br><span class="line"></span><br><span class="line">#### 变量名variable names 重新命名。</span><br><span class="line">iris %&gt;% </span><br><span class="line">  rename_all(tolower) %&gt;% </span><br><span class="line">  rename_all(~str_replace_all(., &quot;\\.&quot;, &quot;_&quot;))</span><br><span class="line"></span><br><span class="line">#### 观测 observation 和 values 值修改</span><br><span class="line">storms %&gt;% </span><br><span class="line">    select(name,year,status) %&gt;% </span><br><span class="line">    mutate_all(tolower) %&gt;% </span><br><span class="line">    mutate_all(~str_replace_all(., &quot;\\s&quot;, &quot;_&quot;))</span><br><span class="line"></span><br><span class="line">storms %&gt;% </span><br><span class="line">    select(name,year,status) %&gt;% </span><br><span class="line">    map(~str_replace(.,&quot;\\s&quot;,&quot;_&quot;)) %&gt;% </span><br><span class="line">    as_tibble()</span><br><span class="line"></span><br><span class="line">#### make new discrete variables based on other columns.</span><br><span class="line">starwars %&gt;%</span><br><span class="line">  select(name, species, homeworld, birth_year, hair_color) %&gt;%</span><br><span class="line">  mutate(new_group = case_when(</span><br><span class="line">      species == &quot;Droid&quot; ~ &quot;Robot&quot;,</span><br><span class="line">      homeworld == &quot;Tatooine&quot; &amp; hair_color == &quot;blond&quot; ~ &quot;Blond Tatooinian&quot;,</span><br><span class="line">      homeworld == &quot;Tatooine&quot; ~ &quot;Other Tatooinian&quot;,</span><br><span class="line">      hair_color == &quot;blond&quot; ~ &quot;Blond non-Tatooinian&quot;,</span><br><span class="line">      TRUE ~ &quot;Other Human&quot;))</span><br></pre></td></tr></table></figure></li></ul></li><li><p>使用<code>summarize()</code>进行分组摘要：</p><ul><li>与<code>group_by</code>一起使用，将整个数据集的单位缩小为单个分组。</li><li>==<code>add_count()</code>== 添加个数统计，而不用summarize<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 使用summarize()进行分组摘要</span><br><span class="line">by_year &lt;- group_by(flights,year,month)</span><br><span class="line">summarise(by_year,delay=mean(arr_delay-dep_delay,na.rm = T))</span><br><span class="line">####查看</span><br><span class="line">(delay_byDay &lt;- group_by(flights,month) %&gt;%summarise(delay_time=mean(dep_delay,na.rm = T))) %&gt;% ggplot(mapping = aes(x=month,y=delay_time))+geom_point()+geom_smooth(se=F)</span><br><span class="line"></span><br><span class="line">#### add the amount of observations without summarising them, and rename them with rename() statement.</span><br><span class="line">mtcars %&gt;% </span><br><span class="line">  select(-(drat:vs)) %&gt;% </span><br><span class="line">  add_count(cyl) %&gt;% rename(n_cyl = n) %&gt;% </span><br><span class="line">  add_count(am) %&gt;% rename(n_am = n)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>利用管道符<code>%&gt;%</code>对数据综合操作：</p><ul><li>综合就是<code>flights %&gt;% group_by(~) %&gt;% summarize(mean(~~,na.rm=T)) %&gt;% filter(~) %&gt;% ggplot(aes())+geom_~()</code></li><li>缺失值：<code>na.rm=T</code>，缺失值计算会都变成缺失值，可利用<code>filter(!is.na(dep_delay),!is.na(arr_delay))</code></li><li>常用的摘要函数：<code>n()</code>, <code>sum()</code>, <code>mean()</code></li><li>中位数<code>median()</code>，分散程度<code>sd()</code>/<code>IQR()</code>/<code>mad()</code></li><li>计数 <code>n()</code>, <strong>计算唯一值的数量<code>n_distinct()</code></strong> 去重复后唯一值的计数，<code>count()</code>可快速的计算。</li><li><strong>逻辑值的计数 和 比例</strong>：<code>summarize(n_early=sum(dep_time&lt;50))</code>,sum找出大于x的True的数量，mean会计算比例。</li></ul></li><li><p>将group_by与filter和mutate结合使用</p><ul><li>根据不同的分组，再利用<code>filter</code>进行筛选<code>flights_sml %&gt;% group_by(year, month, day) %&gt;%  filter(rank(desc(arr_delay)) &lt; 10)</code></li></ul></li><li><p>其它一些dplyr中的函数</p><ul><li><code>distinct(&quot;&quot;, .keep_all=T)</code> base中的unique替代函数。</li></ul></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"># 使用summarize()进行分组摘要</span><br><span class="line">by_year &lt;- group_by(flights,year,month)</span><br><span class="line">summarise(by_year,delay=mean(arr_delay-dep_delay,na.rm = T))</span><br><span class="line">####查看</span><br><span class="line">(delay_byDay &lt;- group_by(flights,month) %&gt;%summarise(delay_time=mean(dep_delay,na.rm = T))) %&gt;% ggplot(mapping = aes(x=month,y=delay_time))+geom_point()+geom_smooth(se=F)</span><br><span class="line"></span><br><span class="line">### 使用管道组合多种操作</span><br><span class="line">(delay_by_dest &lt;- group_by(flights,dest)%&gt;%summarise(count=n(),delay_time=mean(dep_time,na.rm = T), dist=mean(distance,na.rm = T))) %&gt;% filter(count&gt;20,dest!=&quot;HNL&quot;) %&gt;% ggplot(mapping = aes(x=dist,y=delay_time))+geom_point(aes(size=count))+geom_smooth(se=F,color=&quot;darkblue&quot;)</span><br><span class="line"></span><br><span class="line">## 管道符 %&gt;%</span><br><span class="line">(delay &lt;- summarise(by_dest,count=n(),dist=mean(distance,na.rm = T),delay=mean(arr_delay,na.rm = T))) ### count=n()统计分组，就是dest城市的个数</span><br><span class="line">delay &lt;- filter(delay,count&gt;20,dest!=&quot;HNL&quot;)## 筛掉飞行记录少的，特殊机场</span><br><span class="line">ggplot(data = delay,mapping = aes(x=dist,y=delay))+geom_point(aes(size=count),alpha=1/3)+geom_smooth(se=F,color=&quot;darkblue&quot;)</span><br><span class="line">(delay_by_dest &lt;- group_by(flights,dest)%&gt;%summarise(count=n(),delay_time=mean(dep_time,na.rm = T), dist=mean(distance,na.rm = T))) %&gt;% filter(count&gt;20,dest!=&quot;HNL&quot;) %&gt;% ggplot(mapping = aes(x=dist,y=delay_time))+geom_point(aes(size=count))+geom_smooth(se=F,color=&quot;darkblue&quot;)</span><br><span class="line">##查看飞机型号与延误时间的关系</span><br><span class="line">flights %&gt;% group_by(tailnum) %&gt;%summarise(count=n(),delay_time=mean(arr_delay,na.rm = T)) %&gt;%arrange(delay_time) %&gt;%ggplot(mapping = aes(x=delay_time))+geom_freqpoly(binwidth = 10)</span><br><span class="line">##查看航班数量 与 飞机延误时间的关系：航班数量少时，平均延误时间的变动特别大</span><br><span class="line">delay_time %&gt;% filter(count&gt;25) %&gt;% ggplot(mapping = aes(x=count,y=delay_time))+geom_point(alpha=1/5)</span><br><span class="line">##其他常用的统计函数</span><br><span class="line">flights_not_cancelled %&gt;% group_by(dest) %&gt;% summarise(carrier=n())</span><br><span class="line">flights_not_cancelled %&gt;% group_by(dest) %&gt;% summarise(carriers=n_distinct(carrier))</span><br><span class="line">flights_not_cancelled %&gt;% group_by(tailnum) %&gt;% summarise(sum(distance))</span><br><span class="line"> </span><br><span class="line">###exercises</span><br><span class="line">##### 查看哪个航空公司延误时间最长</span><br><span class="line">flights_not_cancelled %&gt;% group_by(carrier) %&gt;% summarise(count=n(),arr_delay_time=mean(arr_delay)) %&gt;% arrange(desc(arr_delay_time)) %&gt;% ggplot(mapping = aes(x=carrier,y=arr_delay_time))+geom_point(aes(size=count))</span><br><span class="line"></span><br><span class="line">### 将group_by和filter结合</span><br><span class="line">flights_sml %&gt;% </span><br><span class="line">  group_by(year, month, day) %&gt;%</span><br><span class="line">  filter(rank(desc(arr_delay)) &lt; 10)</span><br><span class="line">#&gt; # A tibble: 3,306 x 7</span><br><span class="line">#&gt; # Groups:   year, month, day [365]</span><br><span class="line">#&gt;    year month   day dep_delay arr_delay distance air_time</span><br><span class="line">#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;</span><br><span class="line">#&gt; 1  2013     1     1       853       851      184       41</span><br><span class="line">#&gt; 2  2013     1     1       290       338     1134      213</span><br><span class="line">#&gt; 3  2013     1     1       260       263      266       46</span><br><span class="line">#&gt; 4  2013     1     1       157       174      213       60</span><br><span class="line">#&gt; 5  2013     1     1       216       222      708      121</span><br><span class="line">#&gt; 6  2013     1     1       255       250      589      115</span><br><span class="line">#&gt; # … with 3,300 more rows</span><br><span class="line"></span><br><span class="line">popular_dests &lt;- flights %&gt;% </span><br><span class="line">  group_by(dest) %&gt;% </span><br><span class="line">  filter(n() &gt; 365)</span><br><span class="line">popular_dests</span><br><span class="line">#&gt; # A tibble: 332,577 x 19</span><br><span class="line">#&gt; # Groups:   dest [77]</span><br><span class="line">#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time</span><br><span class="line">#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;</span><br><span class="line">#&gt; 1  2013     1     1      517            515         2      830            819</span><br><span class="line">#&gt; 2  2013     1     1      533            529         4      850            830</span><br><span class="line">#&gt; 3  2013     1     1      542            540         2      923            850</span><br><span class="line">#&gt; 4  2013     1     1      544            545        -1     1004           1022</span><br><span class="line">#&gt; 5  2013     1     1      554            600        -6      812            837</span><br><span class="line">#&gt; 6  2013     1     1      554            558        -4      740            728</span><br><span class="line">#&gt; # … with 332,571 more rows, and 11 more variables: arr_delay &lt;dbl&gt;,</span><br><span class="line">#&gt; #   carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;,</span><br><span class="line">#&gt; #   air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;</span><br></pre></td></tr></table></figure><ol start="10"><li>取消分组：<code>ungroup()</code>函数：</li></ol><h2 id="五，探索性数据分析-exploratory-data-analysis-EDA"><a href="#五，探索性数据分析-exploratory-data-analysis-EDA" class="headerlink" title="五，探索性数据分析 exploratory data analysis(EDA)"></a>五，探索性数据分析 exploratory data analysis(EDA)</h2><p><strong>变动</strong>：是一个变量内部的行为，每次测量时数据值的变化趋势。<br><strong>相关变动</strong>：两个或多个变量以相关的方式共同变化所表现出的趋势。多个变量之间的行为。<br><strong>模式</strong>：如果两个变量之间存在系统性的关系，那么这种关系就会再数据中表示一种模式。  </p><p>5.3 <strong>变动:variation describes the behavior within a variable</strong></p><p>一维数据的表示：<code>geom_bar(binwidth=1)</code>可以对一维连续变量进行分箱，然后使用条形的高度表示落入箱中的数量。并且对于<code>geom_bar()</code>,<code>geom_histogram()</code>可以利用<code>geom_freqpoly()</code>替代，此为叠加的折线图，并可以在折线图内<code>aes(color= *)</code>参数映射其它数据。</p><p>异常值：可用图层<code>coord_cartesian(ylim=c(0,50))</code>滤出（不显示，但会保留）大于此取值的，而不是ylim(0,50)直接丢弃。</p><ul><li><strong>将异常值当做缺失值处理</strong>：利用<code>mutate()</code>函数创建新变量代替原来的变量，使用ifelse()函数将异常值替换为NA：<ul><li><code>diamons %&gt;% mutate(y = ifelse(y &lt; 3 | y&gt;20, NA, y))</code></li><li>计算画图时以参数<code>na.rm=TRUE</code>过滤掉</li></ul></li><li>异常值差异不大的，可以用缺失值来代替，而异常值较大的需要探究其原因。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">## 5.3 变动，分布进行可视化表示</span><br><span class="line">ggplot(data = diamonds)+geom_bar(mapping = aes(x=cut))</span><br><span class="line">ggplot(data = diamonds)+geom_bar(mapping = aes(x=carat),binwidth = 0.5)</span><br><span class="line">diamonds %&gt;% filter(carat&lt;3) %&gt;% ggplot(mapping = aes(x=carat))+geom_histogram(binwidth = 0.1)</span><br><span class="line">diamonds %&gt;% filter(carat&lt;3) %&gt;% ggplot(mapping = aes(x=carat))+ geom_freqpoly(aes(color=cut),binwidth=0.1)+scale_color_brewer(palette = &quot;Set1&quot;)</span><br><span class="line"></span><br><span class="line">### 5.3.3异常值，</span><br><span class="line">ggplot(diamonds)+geom_histogram(mapping = aes(x=y),binwidth = 0.5)+ylim(0,60)</span><br><span class="line">ggplot(diamonds)+geom_histogram(mapping = aes(x=y),binwidth = 0.5)+coord_cartesian(ylim = c(0,60))</span><br><span class="line"></span><br><span class="line"># 5.4 异常值,推荐是将异常值改为缺失值处理。</span><br><span class="line">diamonds %&gt;% filter(between(y,3,20))</span><br><span class="line">#### mutate()创建新变量代替原来的变量</span><br><span class="line">diamonds &lt;- diamonds %&gt;% mutate(y=ifelse(y&lt;3 | y&gt;30,NA,y))</span><br><span class="line">diamonds &lt;- select(diamonds,-(`ifelse(y &lt; 3 | y &gt; 30, NA, y)`))</span><br><span class="line">ggplot(diamonds,aes(x=x,y=y))+geom_point(na.rm = T)</span><br><span class="line">flights %&gt;% mutate(cancelled=is.na(dep_time),sched_hour=sched_dep_time%/%100,sched_min=sched_dep_time%%100,sched_depart_time=sched_hour+sched_min/60) %&gt;% select(sched_hour,sched_min,sched_depart_time,everything()) %&gt;% ggplot(aes(x=sched_depart_time))+geom_freqpoly(aes(color=cancelled),binwidth=1/5)</span><br></pre></td></tr></table></figure><p>5.5 <strong>相关变动covariation describes the behavior between variables</strong>：</p><ul><li>分类变量与连续变量：<ul><li>对<code>geom_freqpoly(aes(color=cut))</code>，对一维的count计数进行标准化可以y=..density..标准化。</li><li>箱线图boxplot()标准化：<strong>reorder(class,hwy,FUN=median)</strong> 对分类变量进行排序。<img src="https://gitee.com/tianpeng__wang/image/raw/master/tianpeng_pic/20200826220653.png" alt=""></li></ul></li><li>两个分类变量：<strong>可以利用heatmap图，geom_tile, geom_count</strong><ul><li>geom_count()函数</li><li>另外可先count(x,y)计数，再利用<code>geom_tile()</code>和<code>geom_count()</code>填充图形属性。</li></ul></li><li>两个连续变量：<ul><li>通常的geom_point(),可通过alpha参数设置透明度。<img src="https://gitee.com/tianpeng__wang/image/raw/master/tianpeng_pic/20200826220803.png" alt=""></li><li>对连续变量数据进行<strong>分箱</strong>，<code>geom_bin2d</code>,<code>geom_hex()</code>可以正方形和六边形分享。</li></ul></li></ul><p>5.6 模式和模型：如果两个变量之间存在系统性的关系，那么这种关系就会再数据中表示一种模式。 </p><ul><li>变动会生成不确定性，那么相关变动就是减少不确定性，如果两个变量是存在系统性的关系的，那么就可以通过一个变量的值来预测另一个变量的值。</li><li><strong>模型</strong>：就是抽取模式的一种工具，找到两个变量间系统性关系的方法。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 5.5 相关变动：两个或者多个变量间的关系。</span><br><span class="line">ggplot(diamonds,mapping = aes(x=price))+geom_freqpoly(aes(color=cut),binwidth=500)</span><br><span class="line">ggplot(diamonds)+geom_freqpoly(aes(x=price,y=..density..,color=cut),binwidth=200)+scale_color_brewer(palette = &quot;Set2&quot;)</span><br><span class="line">###mpg</span><br><span class="line">ggplot(mpg,mapping = aes(x=class,y=hwy))+geom_boxplot()</span><br><span class="line">ggplot(mpg)+geom_boxplot(mapping = aes(x=reorder(class,hwy,FUN = mean),y=hwy,fill=class))</span><br><span class="line">ggplot(mpg)+geom_boxplot(mapping = aes(x=reorder(class,hwy,FUN=median),y=hwy))+coord_flip()</span><br><span class="line"></span><br><span class="line">### 5.5.1分类变量与连续变量</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 5.5.2俩个分类变量间的关系，geom_tile(aes(fill=count))</span><br><span class="line">ggplot(data = diamonds)+geom_count(mapping = aes(x=cut,y=color))</span><br><span class="line">diamonds %&gt;% count(color,cut) %&gt;% ggplot()+geom_tile(aes(x=color,y=cut,fill=n))</span><br><span class="line"></span><br><span class="line">### 5.5.3 两个连续变量</span><br><span class="line">geom_point()</span><br><span class="line">geom_bin2d() ## 对连续变量的数据做分箱处理。</span><br><span class="line">geom_hex()</span><br><span class="line">diamonds %&gt;% ggplot(aes(carat,price))+geom_hex()</span><br></pre></td></tr></table></figure><img src="https://gitee.com/tianpeng__wang/image/raw/master/tianpeng_pic/20200829161817.jpg" alt=""></li></ul><h2 id="七，-tibble"><a href="#七，-tibble" class="headerlink" title="七， tibble"></a>七， tibble</h2><p>是对传统R中的data.frame的升级版替换。</p><ul><li>tibble在打印大数据时会默认仅显示10行(observation)，屏幕可显示的列(variety)</li><li>转换传统的data frame to tibble with <code>as_tibble()</code></li><li>打印tibble显示在控制台时，有时需要比默认的显示更多的输出。可利用<code>print(n=10,width=Inf)</code> or <code>options(tibble.print_max = n, tibble.print_min = m)</code>, <code>options(tibble.width = Inf)</code>.</li><li>==取子集，需要利用占位符df %&gt;% .$x==</li><li>一些老的base函数不支持tibble, 可利用<code>as.data.frame()</code>转换回。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">tb &lt;- tibble(</span><br><span class="line">  x = 1:5, </span><br><span class="line">  y = 1, </span><br><span class="line">  z = x ^ 2 + y</span><br><span class="line">)</span><br><span class="line">tb</span><br><span class="line"></span><br><span class="line">nycflights13::flights %&gt;% </span><br><span class="line">  print(n = 10, width = Inf)</span><br><span class="line">  </span><br><span class="line">df %&gt;% .$x</span><br><span class="line">#&gt; [1] 0.7330 0.2344 0.6604 0.0329 0.4605</span><br><span class="line">df %&gt;% .[[&quot;x&quot;]]</span><br><span class="line">#&gt; [1] 0.7330 0.2344 0.6604 0.0329 0.4605</span><br></pre></td></tr></table></figure></li></ul><h2 id="八，-使用readr进行数据的导入"><a href="#八，-使用readr进行数据的导入" class="headerlink" title="八， 使用readr进行数据的导入"></a>八， 使用readr进行数据的导入</h2><p>8.1 常用的tidyverse所提供的数据导入的方式：</p><ul><li><code>read_csv()</code>：以,分割</li><li><code>read_csv2()</code>：以;分割</li><li><code>read_tsv()</code>：以\t分割</li><li><code>read_delim()</code>：可以读取以任意分隔符的文件delim=”\t” (delimiter 分界符)</li></ul><p>8.2 <strong>以read_csv()为例，内部提供的函数：</strong></p><ul><li>skip=2，跳过开头的n行</li><li>comment=”#” 跳过以#开头的行</li><li>==col_names=FALSE 不以第一行作为列标题。也可col_names=c(“a”,”b”,”c”)来对列进行命名==</li><li>na=”.” 设定哪个值为文件的缺失值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">read_csv(&quot;file.csv&quot;,skip=1,col_names=c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;)) ## 读取文件file.csv，跳过第一行，并自定义列的名字。</span><br></pre></td></tr></table></figure><p>8.3 解析向量：主要依靠<code>parse_*()</code>函数族解析，第一个参数为需要解析的字符向量，na参数设定 缺失值处理na=”.”，函数族包括parse_logical(), parse_double(), character(), factor(), datetime().</p><ul><li><strong>parse_number()</strong>可以忽略数值前后的非数值型字符，<strong>可以处理 货币/百分比，提取嵌在文本中的数值</strong></li><li>character：UTF-8可以对人类使用的所有字符进行编码，ASCII为美国信息交换标准代码。</li><li>因子：表示 <strong>已知集合的分类变量</strong></li><li>日期时间等</li></ul><p>8.4 解析文件：readr会通过文件的前1000行以启发式算法guess_parser()返回readr最可信的猜测，接着用parse_guess()使用这个猜测来解析列。</p><p>8.5 写入文件和其它导入文件：</p><ul><li>通过<code>write_csv</code>,<code>write_tsv</code>，其会自动使用UTF-8对字符串编码。==<code>append=T</code>会覆盖已有文件==</li><li><code>write_excel_csv()</code>函数导为Excel文件。</li><li><code>readxl</code>可以读取EXCEL文件</li><li><code>haven</code>读取SPSS,SAS数据</li><li><code>DBI</code>可对RMySQL等数据库查询</li><li><code>jsonlite</code>读取JSON的层次数据。</li><li><code>xml2</code>读取XML文件数据</li></ul><h2 id="九，使用tidyr整理数据表-Tidy-data"><a href="#九，使用tidyr整理数据表-Tidy-data" class="headerlink" title="九，使用tidyr整理数据表 Tidy data"></a>九，使用tidyr整理数据表 Tidy data</h2><blockquote><p>“Tidy datasets are all alike, but every messy dataset is messy in its own way.” –– Hadley Wickham</p></blockquote><p>整洁的数据基本准则(以tidyr内部数据table1,table2,table3,table4a,table4b)为例：</p><ul><li>每个变量(variables)都只有一列；</li><li>每个观测(observation)只有一行；</li><li>每个数据仅有一个位置cell。</li></ul><p><img src="https://gitee.com/tianpeng__wang/image/raw/master/tianpeng_pic/20200829173223.png" alt=""></p><p>整理数据表，应对一个变量对应多行 or 一个观测对应多行的问题。利用<code>gather</code>，<code>spread()</code></p><ol><li><p><code>gather()</code>：对于table4a来说，其存在两列1999/2000对应相同的变量值。故需要合并，合并后的两列重新起名字，根据<code>key=&quot;&quot;</code>，和<code>value=&quot;&quot;</code>。</p><ul><li><code>table4a %&gt;% gather(</code>1999<code>,</code>2000<code>,key=&quot;year&quot;,value=&quot;cases&quot;)</code></li><li><code>pivot_longer(c(</code>1999<code>,</code>2000<code>),names_to=&quot;year&quot;,values_to=&quot;cases&quot;)</code><br><img src="https://gitee.com/tianpeng__wang/image/raw/master/tianpeng_pic/20200829175608.png" alt=""><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">tidy4a &lt;- table4a %&gt;% </span><br><span class="line">  pivot_longer(c(`1999`, `2000`), names_to = &quot;year&quot;, values_to = &quot;cases&quot;)</span><br><span class="line">tidy4b &lt;- table4b %&gt;% </span><br><span class="line">  pivot_longer(c(`1999`, `2000`), names_to = &quot;year&quot;, values_to = &quot;population&quot;)</span><br><span class="line">left_join(tidy4a, tidy4b)</span><br><span class="line">#&gt; Joining, by = c(&quot;country&quot;, &quot;year&quot;)</span><br><span class="line">#&gt; # A tibble: 6 x 4</span><br><span class="line">#&gt;   country     year   cases population</span><br><span class="line">#&gt;   &lt;chr&gt;       &lt;chr&gt;  &lt;int&gt;      &lt;int&gt;</span><br><span class="line">#&gt; 1 Afghanistan 1999     745   19987071</span><br><span class="line">#&gt; 2 Afghanistan 2000    2666   20595360</span><br><span class="line">#&gt; 3 Brazil      1999   37737  172006362</span><br><span class="line">#&gt; 4 Brazil      2000   80488  174504898</span><br><span class="line">#&gt; 5 China       1999  212258 1272915272</span><br><span class="line">#&gt; 6 China       2000  213766 1280428583</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>spread()</code>：对于table2来说，存在冗余。需要拆分出多个变量</p><ul><li><code>table2 %&gt;% spread(table2,key=type,value=count)</code></li><li><code>pivot_wider(names_from = type,values_from=count)</code><br><img src="https://gitee.com/tianpeng__wang/image/raw/master/tianpeng_pic/20200829175923.png" alt=""></li></ul></li><li><p><code>separate()</code>：对于table3来说，rate一列数据可以拆分。</p><ul><li><code>separate(table3,rate,into=c(&quot;cases&quot;,&quot;population&quot;))</code><br><img src="https://gitee.com/tianpeng__wang/image/raw/master/tianpeng_pic/20200830234626.png" alt=""></li><li><code>sep=</code>参数默认是以非数字 非字母的字符为分隔符，也可以指定分隔符根据正则匹配。sep=4表示以4个字符作为分隔符。</li><li>==<code>convert = TRUE</code>表示改变分割后的数据结构。<code>separate()</code>默认切割后的数据结构是character。==</li></ul></li><li><p><code>unite()</code>：对指定两列合并处理。</p><ul><li>unite(new,centry,year,sep=””)<br><img src="https://gitee.com/tianpeng__wang/image/raw/master/tianpeng_pic/20200830235558.png" alt=""></li></ul></li><li></li></ol><ul><li><strong><code>rename()</code>，<code>rename_all()</code>：</strong> <strong>对variables变量进行重命名</strong>。通过library(stringr)。<ul><li><code>rename_all(tolower) %&gt;% rename_all(~str_replace_all(., &quot;\\.&quot;, &quot;_&quot;))</code></li></ul></li><li><code>mutate()</code>，<code>mutate_all()</code>：<strong>对所有的value进行重命名，修改名称</strong><ul><li><code>mutate_all(tolower) %&gt;% mutate_all(~str_replace_all(., &quot; &quot;, &quot;_&quot;))</code></li></ul></li><li><code>rowwise()</code>，对每行的数据进行处理，加和/平均值处理。<ul><li><code>iris %&gt;% select(contains(&quot;Length&quot;)) %&gt;% rowwise() %&gt;% mutate(avg_length = mean(c(Petal.Length, Sepal.Length)))</code></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">## 1 tidy_data</span><br><span class="line">#### compare different dataset</span><br><span class="line">table1</span><br><span class="line">table2</span><br><span class="line">table3</span><br><span class="line">table4a;table4b</span><br><span class="line"></span><br><span class="line">table1 %&gt;% mutate(rate=cases/population *10000)</span><br><span class="line">table1 %&gt;% count(year,wt=cases)</span><br><span class="line">ggplot(table1,aes(year,cases)) + geom_line(aes(color=country))+geom_point(color=&quot;grey&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 2 gather()</span><br><span class="line">table4a</span><br><span class="line">table4a %&gt;% gather(`1999`,`2000`,key = &quot;year&quot;,value = &quot;cases&quot;)</span><br><span class="line">table4b %&gt;% gather(`1999`,`2000`,key=&quot;year&quot;,value=&quot;population&quot;)</span><br><span class="line">left_join(table4a,table4b,by=c(&quot;country&quot;,&quot;year&quot;))</span><br><span class="line"></span><br><span class="line">## 3 spread()</span><br><span class="line">table2</span><br><span class="line">table2 %&gt;% spread(key = type,value = count)</span><br><span class="line"></span><br><span class="line">stocks &lt;- tibble(</span><br><span class="line">  year=c(2015,2015,2016,2016),</span><br><span class="line">  half=c(1,2,1,2),</span><br><span class="line">  return=c(1.88,0.59,0.92,0.17)</span><br><span class="line">)</span><br><span class="line">stocks</span><br><span class="line"></span><br><span class="line">stocks %&gt;% spread(year,return) %&gt;% gather(&quot;year&quot;,&quot;return&quot;,`2015`,`2016`)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 综合操作</span><br><span class="line">who %&gt;%</span><br><span class="line">  gather(new_sp_m014:newrel_f65,key=&quot;key&quot;,value=&quot;count&quot;,na.rm = T) %&gt;%</span><br><span class="line">  mutate(key=str_replace(key,&quot;newrel&quot;,&quot;new_rel&quot;)) %&gt;%</span><br><span class="line">  separate(key,into = c(&quot;new&quot;,&quot;var&quot;,&quot;sexage&quot;),sep=&quot;_&quot;) %&gt;%</span><br><span class="line">  select(-iso2,-iso3,-new) %&gt;%</span><br><span class="line">  separate(sexage,into = c(&quot;sex&quot;,&quot;age&quot;),sep=1)</span><br></pre></td></tr></table></figure><h2 id="九，使用dplyr处理关系数据，多个数据表。"><a href="#九，使用dplyr处理关系数据，多个数据表。" class="headerlink" title="九，使用dplyr处理关系数据，多个数据表。"></a>九，使用dplyr处理关系数据，多个数据表。</h2><p>综合多个表中的数据来解决感兴趣的问题。存在于多个表中的数据称为<strong>关系数据</strong>。且<strong>关系总是定义于两个表之间的。</strong> 包括有三类操作处理关系数据：</p><ul><li>合并数据：在一个表中添加另一个表的新变量，添加新变量的方式是以连接两个表的键来实现的。</li><li>筛选连接：在A表中，根据键是否存在于B表中来筛选这个A表中的数据。</li><li>集合操作：将观测作为集合元素来处理。</li></ul><p>基本数据的准备包括<code>nycflights13</code>包中的几个表。airlines/airports/planes/weather等。</p><p>9.3 键：<strong>唯一标识</strong>观测的变量（A key is a variable (or set of variables) that uniquely identifies an observation）</p><ul><li>主键(primary key)：唯一标识 其所在数据表中的观测(不重复)例如planes$tailnum。可利用<code>count() %&gt;% filter(n&gt;1)</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">planes %&gt;% </span><br><span class="line">  count(tailnum) %&gt;% </span><br><span class="line">  filter(n &gt; 1)</span><br><span class="line">#&gt; # A tibble: 0 x 2</span><br><span class="line">#&gt; # … with 2 variables: tailnum &lt;chr&gt;, n &lt;int&gt;</span><br><span class="line"></span><br><span class="line">weather %&gt;% </span><br><span class="line">  count(year, month, day, hour, origin) %&gt;% </span><br><span class="line">  filter(n &gt; 1)</span><br><span class="line">#&gt; # A tibble: 3 x 6</span><br><span class="line">#&gt;    year month   day  hour origin     n</span><br><span class="line">#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt;  &lt;int&gt;</span><br><span class="line">#&gt; 1  2013    11     3     1 EWR        2</span><br><span class="line">#&gt; 2  2013    11     3     1 JFK        2</span><br><span class="line">#&gt; 3  2013    11     3     1 LGA        2</span><br></pre></td></tr></table></figure></li><li>外键(foreign key)：唯一标识 另一个数据表中的观测例如flights$tailnum。</li><li>代理键：当一张表没有主键，需要使用<code>mutate()</code>函数和<code>row_number()</code>函数为表加上一个主键。</li><li>理解不同数据表之间的关系的关键时：==<strong>记住每种关系只与两张表有关</strong>==，不需要清楚所有的事情，只需要明白所关心的表格即可。<ul><li>例如 flights 与 planes相连接 via tailnum。flights 连接airlines通过carrier.等<br><img src="https://gitee.com/tianpeng__wang/image/raw/master/tianpeng_pic/20200831235621.png" alt=""></li></ul></li></ul><p>9.4 <strong>合并连接(mutating join)</strong>：通过两个表中的键（变量们）来匹配观测（行数值），再将一个表中的变量复制到另一个表格中。 <strong>对比cheatsheet中的信息</strong></p><ul><li><p><strong>内连接</strong>：相当于连取交集。将两个表中的相等的键值取出来。<code>X %&gt;% inner_join(y,by=&quot;key&quot;)</code><br><img src="https://gitee.com/tianpeng__wang/image/raw/master/tianpeng_pic/20200901002207.png" alt=""></p></li><li><p><strong>外连接</strong>：至少保留存在于一个表中的观测。在另一个表中未匹配的变量会以<code>NA</code>表示。</p><ul><li><code>left_join()</code> keeps all observations in x.<strong>最常用的join</strong></li><li><code>right_join()</code> keeps all observations in y</li><li><code>full_join()</code> keeps all observations in x and y<br><img src="https://gitee.com/tianpeng__wang/image/raw/master/tianpeng_pic/20200901002608.png" alt=""></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flights2 %&gt;% left_join(airlines,by=&quot;carrier&quot;)</span><br><span class="line">## in base R</span><br><span class="line"></span><br><span class="line">flights2 %&gt;% mutate(name=airlines$name[match(carrier,airlines$carrier)])</span><br></pre></td></tr></table></figure><ul><li><p><strong>重复键</strong>：一对多（），多对一，以及多对多的关系（两表中都不唯一，会以笛卡尔积分的方式呈现）。</p></li><li><p><strong>定义两个表中匹配的键</strong>：</p><ul><li>by=NULL，默认，使用存在于两个表中的所有变量。</li><li><code>left_join(x,y,by=&quot;weather&quot;)</code></li><li><code>left_join(x,y,c(&quot;dest&quot;=&quot;faa &quot;))</code><br><img src="https://gitee.com/tianpeng__wang/image/raw/master/tianpeng_pic/20200901002916.png" alt=""></li></ul></li><li><p>其它Implementations: <strong>base:merge()</strong></p><ul><li>Baes:merge: <code>left_join(x, y)</code> &lt;=&gt; <code>merge(x, y, all.x = TRUE)</code></li><li>SQL: <code>left_join(x, y, by = &quot;z&quot;)</code>    &lt;=&gt; <code>SELECT * FROM x LEFT OUTER JOIN y USING (z)</code></li></ul></li></ul><p>9.5 筛选连接(Filtering joins)：<strong>根据键来对观测数值进行筛选，用一组数据来筛选另一组数据</strong></p><ul><li>semi_join(x,y,by=””)：保留x表中 与 y表中的观测数值相匹配的数据。<ul><li><img src="https://gitee.com/tianpeng__wang/image/raw/master/tianpeng_pic/20200901211155.png" alt=""></li></ul></li><li>anti_join(x,y)：丢弃x表中 与y表中观测(行)数据相匹配的数据。<ul><li><img src="https://gitee.com/tianpeng__wang/image/raw/master/tianpeng_pic/20200901211440.png" alt=""></li></ul></li></ul><p>9.6整理数据时需要对数据进行整理：</p><ol><li>需要找出每个表中可以作为主键的变量。应基于数据的真实含义来找主键</li><li>确保主键中的每个变量没有缺失值，如果有缺失值则不能被识别！</li><li>检查主键是否可以与另一个表中的外键相匹配。利用<code>anti_join()</code>来确定。</li></ol><p>9.7集合的操作：</p><ul><li><code>intersect(x,y)</code> 两个表中皆存在。</li><li><code>union()</code>：返回x表中与y表中的唯一观测。</li><li><code>setdiff()</code>：在x表中，但不在y表中的数值。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">library(tidyverse)</span><br><span class="line">library(nycflights13)</span><br><span class="line">planes;airports;airlines;weather;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 9.3键</span><br><span class="line">weather %&gt;% count(year,month,day,hour,origin) %&gt;% filter(n&gt;1) ### 筛选唯一的键</span><br><span class="line"></span><br><span class="line">## 9.4 合并连接</span><br><span class="line">flights2 &lt;- flights %&gt;% select(year:day,hour,origin,dest,tailnum,carrier)</span><br><span class="line">flights2 %&gt;% select(-(hour:origin)) %&gt;% left_join(airlines,by = &quot;carrier&quot;)</span><br><span class="line">flights2 %&gt;% select(-(hour:origin)) %&gt;% right_join(airlines,by = &quot;carrier&quot;)</span><br><span class="line"></span><br><span class="line">flights2 %&gt;% left_join(weather) ## 自然连接,使用存在于两个表中的所有变量。</span><br><span class="line">flights2 %&gt;% left_join(planes,by = &quot;tailnum&quot;) ## 共有的</span><br><span class="line">flights2 %&gt;% left_join(airports,c(&quot;origin&quot; = &quot;faa&quot;))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### exercise</span><br><span class="line">##9.4.6-1目的地的平均延误时间，与空间分布。</span><br><span class="line">flights %&gt;% group_by(dest) %&gt;% summarise(dest_delay=mean(arr_delay,na.rm = T)) %&gt;% left_join(airports,c(&quot;dest&quot;=&quot;faa&quot;)) %&gt;% filter(dest_delay&gt;0)%&gt;%ggplot(aes(lon,lat))+borders(&quot;state&quot;)+geom_point(aes(size=dest_delay))</span><br><span class="line"></span><br><span class="line">airports %&gt;% semi_join(flights,c(&quot;faa&quot;=&quot;dest&quot;)) %&gt;% ggplot(aes(lon,lat))+borders(&quot;state&quot;)+geom_point()</span><br><span class="line">##exercise3 飞机的机龄与延误时间</span><br><span class="line">flights %&gt;% group_by(tailnum) %&gt;% summarise(count=n(),delay_tailnum=mean(arr_delay,na.rm = T)) %&gt;% left_join(planes,by=&quot;tailnum&quot;) %&gt;% filter(!is.na(year)) %&gt;% ggplot(aes(x=delay_tailnum))+geom_freqpoly(aes(color=year),binwidth=1)</span><br><span class="line">###geom_ribbon作图</span><br><span class="line"></span><br><span class="line">## 9.5 筛选连接</span><br><span class="line">(top_dest &lt;- flights %&gt;% count(dest,sort = T) %&gt;% head(10))</span><br><span class="line">flights %&gt;% filter(dest %in% top_dest$dest)</span><br><span class="line"></span><br><span class="line">flights %&gt;% semi_join(top_dest,by = &quot;dest&quot;)</span><br></pre></td></tr></table></figure><h2 id="十章-使用stringr处理字符串。"><a href="#十章-使用stringr处理字符串。" class="headerlink" title="十章 使用stringr处理字符串。"></a>十章 使用stringr处理字符串。</h2><p>字符串通常包含的是非结构化或者半结构化的数据。</p><h5 id="10-1-字符串基础"><a href="#10-1-字符串基础" class="headerlink" title="10.1 字符串基础"></a>10.1 字符串基础</h5><p>R基础函数中含有一些字符串处理函数，但方法不一致，不便于记忆。推荐使用stringr函数。<strong>函数是以str_开头</strong></p><ol><li>字符串的长度length: <code>str_length()</code></li><li>字符串的组合combine: <code>str_c(&quot;x&quot;,&quot;y&quot;,sep = &quot;_&quot;)</code><ul><li>向量化函数，自动循环短向量，使得其与最长的向量具有相同的长度</li><li>x &lt;- c(“abc”, NA) ; str_c(“1_”,str_replace_na(x),”_1”)</li></ul></li><li>字符串character取子集subsetting strings(==根据位置==)：<code>str_sub(x, start, end)</code>。<strong>如果是一个向量，则对向量中的每个字符串操作，截取子集</strong><ul><li>对向量x&lt;- c(“Apple”,”Banana”, “Pear”)中的每个字符串 第一个字母 小写化。==<code>str_sub(x,1,1) &lt;- str_to_lower(str_sub(x,1,1))</code>==</li></ul></li><li>文本转化为大小写：全部大写<code>str_to_upper()</code>, 首字母大写<code>str_to_title()</code></li><li>对向量内的strings按照ENGLISH进行排序：<code>str_sort(c(&quot;apple&quot;,&quot;eggplant&quot;,&quot;banana&quot;), locale=&quot;en&quot;)</code></li></ol><h5 id="10-2-正则匹配"><a href="#10-2-正则匹配" class="headerlink" title="10.2 正则匹配"></a>10.2 正则匹配</h5><p>利用str_view()学习正则匹配，需安装library(htmltools), htmlwidgets</p><ol><li>str_view(x, “abc”)</li><li>锚点：^ $; 单词边界：<code>\b</code>,<strong>如匹配一个单词</strong> <code>\bsum\b</code></li><li>特殊匹配符号：\\d, \\s, \\w, [abc], <strong>[^abc]不匹配a/b/c</strong></li><li>数量：? +  *  {n,m}  (..)\\1</li><li>分组和反引用：(..)\\1</li></ol><h5 id="10-3-各类匹配操作"><a href="#10-3-各类匹配操作" class="headerlink" title="10.3 各类匹配操作"></a>10.3 各类匹配操作</h5><ol><li><p>匹配检测：返回逻辑值TURE(1) or FALSE(0) ==<code>str_detect(x, &quot;e$&quot;)</code>==</p><ul><li>利用sum(), mean()简单统计匹配的个数。</li><li>逻辑取子集方法筛选：words[str_detect(words,”x$”)]</li><li><strong>与dplyr使用的另一种技巧</strong> ：<code>df %&gt;% filter(str_detect(words,&quot;ab&quot;))</code></li><li>等同于== <code>str_subset(words,&quot;x$&quot;)</code> ==</li><li>==<code>str_count(words, &quot;[aeiou]&quot;)</code>== 返回字符串中匹配的数量。</li><li>与dplyr一起使用：<code>df %&gt;% mutate( vowels=str_count(w,&quot;[aeiou]&quot;))</code></li></ul></li><li><p>提取匹配的内容：== <code>str_extract()</code> == 只提取第一个匹配的内容。</p><ul><li><code>str_extract_all(words,color_match)</code>返回一个列表，包含所有匹配的内容。</li><li><code>str_extract_all(words,color_match, simplify= TRUE)</code> 返回的是一个矩阵。</li><li><strong>注意与str_subset()区别，subset是取子集，取所有匹配到的，无匹配的舍去。子集。而extract是取匹配到的字符串，无匹配到字符串返回NA。可先利用str_subset()找到包含匹配的chr，再用str_extract()</strong> 找到包含的匹配。</li><li><code>str_match()</code></li><li>利用tidyr里的== <code>extract()</code> ==将字符串向量提取匹配的字符串并转变为tibble</li><li><img src="https://gitee.com/tianpeng__wang/image/raw/master/tianpeng_pic/20200901233801.png" alt=""></li></ul></li><li><p>替换匹配的内容 <code>str_replace(words, &quot;match_x&quot;, &quot;replace_x&quot;)</code></p><ul><li>同时替换多个匹配的内容：<code>str_replace_all()</code></li><li>同时执行多个替换：<code>str_replace_all(words,c(&quot;1&quot;=&quot;one&quot;,&quot;2&quot;=&quot;two&quot;,&quot;3&quot;=&quot;three&quot;))</code></li><li><img src="https://gitee.com/tianpeng__wang/image/raw/master/tianpeng_pic/20200901234031.png" alt=""></li></ul></li><li><p>拆分 <code>split(sentences,&quot; &quot;)</code>返回的是一个<strong>列表</strong></p><ul><li><code>&quot;a|b|c|d&quot; %&gt;% str_split(&quot;\\|&quot;) %&gt;% .[[1]]</code></li><li>内置的单词边界函数boundary()，会自动识别单词外的字符<code>str_split(x, boundary(&quot;word&quot;))</code></li></ul></li><li><p>定位：<code>str_locate</code>返回匹配在字符串中的位置。</p><ul><li>使用str_locate()找出匹配的模式，再用str_sub()提取或修改匹配的内容。</li></ul></li><li><p>其它模式：</p><ul><li><code>regex()</code></li><li><code>fixed()</code></li><li><code>coll()</code></li></ul></li></ol><h5 id="10-5-其它类型的匹配"><a href="#10-5-其它类型的匹配" class="headerlink" title="10.5 其它类型的匹配"></a>10.5 其它类型的匹配</h5><p>对于一个匹配的”pattern”来说，其完整的写法是regex(“pattern”)。而regex()函数中包含其它的参数</p><ul><li><code>ignore_case=T</code>忽略匹配的大小写</li><li><code>multiline=T</code> 可以跨行匹配</li><li><code>comments = T</code> 可以添加注释信息</li><li><code>dotall=T</code>可以匹配所有字符</li></ul><p><strong>其它应用：当想不起函数名称时可以<code>apropos(&quot;pattern&quot;)</code></strong></p><table><thead><tr><th>函数</th><th>功能说明</th><th>R Base中对应函数</th></tr></thead><tbody><tr><td>使用正则表达式的函数</td><td></td><td></td></tr><tr><td>str_subset()</td><td>返回匹配到的子集列表</td><td></td></tr><tr><td>str_extract()</td><td>提取首个匹配模式的字符</td><td>regmatches()</td></tr><tr><td>str_extract_all()</td><td>提取所有匹配模式的字符</td><td>regmatches()</td></tr><tr><td>str_locate()</td><td>返回首个匹配模式的字符的位置</td><td>regexpr()</td></tr><tr><td>str_locate_all()</td><td>返回所有匹配模式的字符的位置</td><td>gregexpr()</td></tr><tr><td>str_replace()</td><td>替换首个匹配模式</td><td>sub()</td></tr><tr><td>str_replace_all()</td><td>替换所有匹配模式</td><td>gsub()</td></tr><tr><td>str_split()</td><td>按照模式分割字符串</td><td>strsplit()</td></tr><tr><td>str_split_fixed()</td><td>按照模式将字符串分割成指定个数</td><td>-</td></tr><tr><td>str_detect()</td><td>检测字符是否存在某些指定模式</td><td>grepl()</td></tr><tr><td>str_count()</td><td>返回指定模式出现的次数</td><td>-</td></tr><tr><td>其他重要函数</td><td></td><td></td></tr><tr><td>str_sub()</td><td>提取指定位置的字符</td><td>regmatches()</td></tr><tr><td>str_dup()</td><td>丢弃指定位置的字符</td><td>-</td></tr><tr><td>str_length()</td><td>返回字符的长度</td><td>nchar()</td></tr><tr><td>str_pad()</td><td>填补字符</td><td>-</td></tr><tr><td>str_trim()</td><td>丢弃填充，如去掉字符前后的空格</td><td>-</td></tr><tr><td>str_c()</td><td>连接字符</td><td>paste(),paste0()</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">## 10.2 字符串基础</span><br><span class="line">str_length(c(&quot;a&quot;,&quot;aaaaa&quot;,NA)) ## str_length 返回字符串中的字符数量</span><br><span class="line">str_c(&quot;x&quot;,&quot;y&quot;,&quot;z&quot;,sep = &quot; &quot;)</span><br><span class="line">str_c(&quot;aaa&quot;,str_replace_na(c(&quot;bbb&quot;,NA)),&quot;ccc&quot;)</span><br><span class="line"></span><br><span class="line">x &lt;- c(&quot;Apple&quot;,&quot;Banana&quot;,&quot;Pear&quot;)</span><br><span class="line">(str_sub(x,1,1) &lt;- str_to_lower(str_sub(x,1,1)))## 对首字母改为小写。</span><br><span class="line">x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 10.3正则表达式进行模式匹配。</span><br><span class="line">str_view(x,&quot;.a&quot;)</span><br><span class="line">str_view(x,&quot;^a&quot;)</span><br><span class="line"></span><br><span class="line">str_view(words,&quot;^.&#123;7,&#125;$&quot;,match = T) ## exercise 只显示7个字母及以上的单词</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 10.4.1匹配检测</span><br><span class="line">df &lt;- tibble(w=words,i=seq_along(words))</span><br><span class="line">df %&gt;% filter(str_detect(w,&quot;ab&quot;)) ##对于tibble表中筛选。</span><br><span class="line">str_subset(words,&quot;^y&quot;)</span><br><span class="line"></span><br><span class="line">mean(str_count(words,&quot;[aeiou]&quot;)) ## 每个单词中元音字母的数量</span><br><span class="line">df %&gt;% mutate(vowels=str_count(w,&quot;[aeiou]&quot;),consonants=str_count(w,&quot;[^aeiou]&quot;)) ## 与mutate一起使用，加一列匹配到元音字母与非元音字母的数</span><br><span class="line"></span><br><span class="line">####exercises</span><br><span class="line">str_subset(words,&quot;x$|^y&quot;)</span><br><span class="line">words[str_detect(words,&quot;x$|^y&quot;)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 10.4.3 提取匹配内容</span><br><span class="line">colors &lt;- c(&quot;red&quot;,&quot;orange&quot;,&quot;yellow&quot;,&quot;green&quot;,&quot;blue&quot;,&quot;purple&quot;)</span><br><span class="line">(color_match &lt;- str_c(colors,collapse = &quot;|&quot;))</span><br><span class="line">has_color &lt;- str_subset(sentences,color_match) ## 提取包含匹配的整个句子</span><br><span class="line">matches &lt;- str_extract(has_color,color_match) ##匹配包含匹配句子 的 第一个匹配内容。</span><br><span class="line">str(matches)</span><br><span class="line">###exercises</span><br><span class="line">str_extract(sentences,&quot;^\\S+&quot;)</span><br><span class="line">str_extract_all(sentences,&quot;\\w+s&quot;)</span><br><span class="line"></span><br><span class="line">words_ing &lt;- str_subset(sentences,&quot;\\b\\w+ing\\b&quot;)</span><br><span class="line">str_extract_all(words_ing,&quot;\\b\\w+ing\\b&quot;)</span><br><span class="line">## 10.4.5 分组匹配</span><br><span class="line">noun &lt;- &quot;(a|the) (\\S+)&quot;</span><br><span class="line">has_noun &lt;- sentences %&gt;% str_subset(noun)</span><br><span class="line">has_noun %&gt;% str_extract(noun) </span><br><span class="line"></span><br><span class="line">sentences %&gt;% str_subset(noun) %&gt;% str_extract(noun)</span><br><span class="line">str_match(has_noun,noun) ## 可以给出每个独立的分组，返回的是一个矩阵。</span><br><span class="line">tibble(sentence=sentences) %&gt;% extract(col = sentence,into = c(&quot;article&quot;,&quot;noun&quot;),regex = &quot;(a|the) (\\w+)&quot;,remove = F)</span><br><span class="line"></span><br><span class="line">## 10.4.7 替换</span><br><span class="line">str_replace()</span><br><span class="line">str_replace_all(words,c(&quot;1&quot;=&quot;one&quot;,&quot;2&quot;=&quot;two&quot;,&quot;3&quot;=&quot;three&quot;))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 10.4.9拆分</span><br><span class="line">&quot;a|b|c|d&quot; %&gt;% str_split(&quot;\\|&quot;) %&gt;% .[[1]]</span><br><span class="line">x &lt;- &quot;This is a sentence&quot;</span><br><span class="line">str_view_all(x,boundary(&quot;word&quot;))  ## 返回句子中的所有单词</span><br><span class="line"></span><br><span class="line">apropos(&quot;str&quot;)</span><br></pre></td></tr></table></figure><h2 id="十一章-使用forcats处理因子"><a href="#十一章-使用forcats处理因子" class="headerlink" title="十一章 使用forcats处理因子"></a>十一章 使用forcats处理因子</h2><p>因子在R中用于处理分类变量。分类变量是在固定的已知集合中取值的变量。</p><p><strong>使用因子时，最常用的两种操作时修改水平的顺序和水平的值。</strong></p><ul><li>factor(x1,levels=c(“a”,”b”,”c”))</li><li>fct_reorder() ## 重新对factor的层级进行确定。</li><li>利用gss_cat数据集，其中一个问题待解决“美国民主党/共和党/中间派的人数比例是如何随时间而变化的”</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">relig_summary &lt;- gss_cat %&gt;%</span><br><span class="line">  group_by(relig) %&gt;%</span><br><span class="line">  summarise(</span><br><span class="line">    age = mean(age, na.rm = TRUE),</span><br><span class="line">    tvhours = mean(tvhours, na.rm = TRUE),</span><br><span class="line">    n = n()</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">ggplot(relig_summary, aes(tvhours, fct_reorder(relig, tvhours))) +</span><br><span class="line">  geom_point()</span><br><span class="line"></span><br><span class="line">### 排序</span><br><span class="line">relig_summary %&gt;%</span><br><span class="line">  mutate(relig = fct_reorder(relig, tvhours)) %&gt;%</span><br><span class="line">  ggplot(aes(tvhours, relig)) +</span><br><span class="line">    geom_point()</span><br></pre></td></tr></table></figure><hr><h2 id="十四章-函数-Functions"><a href="#十四章-函数-Functions" class="headerlink" title="十四章 函数(Functions)"></a>十四章 函数(Functions)</h2><p>当一段代码需要多次使用的时候就可以写函数来实现。先编写工作代码，而后再转换成函数的代码。包括<strong>名称/参数/主体代码</strong></p><ul><li><code>range()</code>返回最小值、最大值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">library(tidyverse)</span><br><span class="line">df &lt;- tibble(a=rnorm(10),</span><br><span class="line">             b=rnorm(10),</span><br><span class="line">             c=rnorm(10),</span><br><span class="line">             d=rnorm(10)</span><br><span class="line">)</span><br><span class="line">x &lt;- df$a</span><br><span class="line">rng &lt;- range(x,na.rm = T) ## range函数返回（最大值和最小值）</span><br><span class="line">(x-rng[1])/(rng[2]-rng[1])</span><br><span class="line"></span><br><span class="line">#### 具体函数</span><br><span class="line">rescale01 &lt;- function(x)&#123;</span><br><span class="line">  rng &lt;- range(x,na.rm = T,finite=T)</span><br><span class="line">  (x-rng[1])/(rng[2]-rng[1])</span><br><span class="line">&#125; ###函数名称为rescale01</span><br><span class="line">rescale01(c(df$a,Inf))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#### exercises</span><br><span class="line">#1, parameters</span><br><span class="line">rescale01_v2 &lt;- function(x,na.rm_TorF,finite_TorF)&#123;</span><br><span class="line">  rng &lt;- range(x,na.rm = na.rm,finite=finite)</span><br><span class="line">  (x-rng[1])/(rng[2]-rng[1])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#2, reverse_Inf</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>命名的规则：函数名一般为<strong>动词</strong>，参数为<strong>名词</strong>。使用注释来解释代码。<ul><li>一些广义的动词例如：get, compute, calculate, determine。</li><li>如果一组函数功能相似，可以类似于stringr包中的str_combine等改后缀的方法。</li><li>==Ctrl + Shift + R== 添加分节的符号</li></ul></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">## exercises</span><br><span class="line">#1,</span><br><span class="line">f1 &lt;- function(string,prefix)&#123;</span><br><span class="line">  substr(string,1,nchar(prefix))==prefix</span><br><span class="line">&#125;</span><br><span class="line">f3 &lt;- function(x,y)&#123;</span><br><span class="line">  rep(y,length.out(x))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>条件执行(condition execution)：if..else..语句<ul><li>condition的值T or F</li><li>if..else语句中使用<strong>逻辑表达式</strong>：&amp;&amp; ，||</li><li><strong>向量化操作符</strong>： &amp;,| 只可以用于多个值。 </li><li>在测试相等关系时，注意 ==是向量化，容易输出多个值。</li><li>if .. else if .. else if .. else.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## exercise2欢迎函数</span><br><span class="line">greet &lt;- function(time=lubridate::now())&#123;</span><br><span class="line">  hr &lt;- lubridate::hour(time)</span><br><span class="line">  if(hr&lt;12)&#123;</span><br><span class="line">    print(&quot;Good morning!&quot;)</span><br><span class="line">  &#125;else if (hr&lt;18) &#123;</span><br><span class="line">    print(&quot;Good afternoon&quot;)</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    print(&quot;Good evening&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">## exercise3</span><br><span class="line">fizzbuzz &lt;- function(x)&#123;</span><br><span class="line">  ###限定输入的内容格式</span><br><span class="line">  stopifnot(length(x)==1)</span><br><span class="line">  stopifnot(is.numeric(x))</span><br><span class="line">  </span><br><span class="line">  if (x%%3==0 &amp;&amp; x%%5!=0) &#123;</span><br><span class="line">    print(&quot;fizz&quot;)</span><br><span class="line">  &#125;else if (x%%5==0 &amp;&amp; x%%3!=0) &#123;</span><br><span class="line">    print(&quot;buzz&quot;)</span><br><span class="line">  &#125;else if (x%%5==0 &amp;&amp; x%%3==0) &#123;</span><br><span class="line">    print(&quot;fizzbuzz&quot;)</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    print(x)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>函数的参数：主要包括进行计算的<strong>数据</strong>，控制计算过程的<strong>细节</strong>，细节参数一般都有默认值<ul><li><strong>检查参数值：stopifnot()</strong></li><li><code>...</code>捕获任意数量的未匹配的参数，将这些捕获的值传递给另一个函数。</li></ul></li><li>返回值：通常是返回最后一个语句的值，可以通过<code>return()</code>提前返回一个值<ul><li>检查语句是否有误。</li></ul></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">## 使用近似正态分布计算均值两端的置信区间</span><br><span class="line">mean_ci &lt;- function(x,confidence=0.95)&#123;</span><br><span class="line">  se &lt;- sd(x)/sqrt(length(x))</span><br><span class="line">  alpha &lt;- 1-confidence</span><br><span class="line">  mean(x)+se*qnorm(c(alpha/2,1-alpha/2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="十五章，-向量vectors"><a href="#十五章，-向量vectors" class="headerlink" title="十五章， 向量vectors"></a>十五章， 向量vectors</h2><h4 id="一-向量概括"><a href="#一-向量概括" class="headerlink" title="一. 向量概括"></a>一. 向量概括</h4><p>向量vectors包括两种：原子向量(atomic vectors)和列表(list)</p><ul><li><strong>原子向量</strong> ：包括6种：logical,numeric(integer, double), character, complex, raw。向量种的各个值都是同种类型的；</li><li><strong>列表</strong>： 递归向量，列表中也可包括其它列表。列表中的各个值可以是不同类型的。</li><li><strong>拓展向量</strong>：向量中任意添加额外的<strong>元数据</strong>。</li><li><strong>探索函数：</strong><code>typeof()</code>, <code>length()</code></li></ul><p><img src="https://gitee.com/tianpeng__wang/image/raw/master/tianpeng_pic/20200903171710.png" alt=""></p><h4 id="二-原子向量"><a href="#二-原子向量" class="headerlink" title="二. 原子向量"></a>二. 原子向量</h4><ol><li>逻辑型(logical)包括三种：TRUE, FALSE, NA</li><li>数值型(numeric):默认数值为双精度型double；<ul><li>注意双精度型double是<strong>近似值(approximations)</strong>，所有的双精度值都当做是近似值处理，表示浮点数(floating point)</li><li>interger的特殊数据<code>NA</code>,double的特殊数据<code>NA, NaN,Inf,-Inf</code>需要以<code>is.finite()</code>等判断</li></ul></li><li>字符串(character)：可以包含任意数量的数据。</li></ol><h4 id="三-原子向量的操作"><a href="#三-原子向量的操作" class="headerlink" title="三. 原子向量的操作"></a>三. 原子向量的操作</h4><ol><li>强制转换：将一种原子强制转化为另一种；或者系统自动转化<ul><li><strong>显示型强制转化</strong>：<code>as.numeric</code>,<code>as.character</code>等；</li><li><strong>隐式强制转化</strong>：联系上下文context自动转化，如logical(T/F)———&gt;numeric(1/0);</li></ul></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- sample(x = 20,size = 100,replace = T)</span><br><span class="line">y &lt;- x&gt;10</span><br><span class="line">mean(y);sum(y)</span><br></pre></td></tr></table></figure><ol start="2"><li><p>检验是否为某一原子向量：利用purrr包中的函数<code>is_</code> ：<code>is_logical(), is_character</code>等</p></li><li><p>标量与循环的规则：处理不同长度的向量会遵循 <strong>向量循环规则</strong>。例如<code>1:10+1:3</code>：R会拓展较短的向量，使其与较长的向量一样长。然后再相加。</p></li><li><p>向量命名：所有类型的向量都是可以命名的.<strong>向量完成后利用：</strong><code>purrr::set_names(x,nm=c(&quot;q&quot;,&quot;w&quot;,&quot;e&quot;))</code>命名。</p></li><li><p>向量的取子集：<code>filter()</code>函数对tibble使用，对于向量的筛选则使用[]。</p><ul><li>整数型数值向量进行筛选：<code>x[c(1,2,2,4)]</code>, <code>x[c(-1,-2,-3)]</code></li><li>==使用逻辑向量取子集，提取出TRUE值对应的元素==。可利用<strong>比较函数</strong></li><li>对命名向量可用字符取子集</li><li><strong>x[]</strong> 代表选取x中的全部元素，对于矩阵十分重要<code>x[2,]</code>,<code>x[,-3]</code>；<strong>特殊的，[[]]</strong> 代表只提取单个元素。明确表示需要提取单个元素时使用</li></ul></li></ol><h4 id="四-列表（递归向量recrusive-vectors）"><a href="#四-列表（递归向量recrusive-vectors）" class="headerlink" title="四. 列表（递归向量recrusive vectors）"></a>四. 列表（递归向量recrusive vectors）</h4><ol><li>列表是建立在原子向量基础上的一种复杂形式，列表可以包含其它列表。列表保存层级结构，树形结构。<code>str()</code>，重点关注列表的结构。</li></ol><p><img src="https://gitee.com/tianpeng__wang/image/raw/master/tianpeng_pic/20200903174212.png" alt=""></p><ol start="2"><li><strong>列表取子集</strong> :<ul><li><code>[]</code>提取子列表，<strong>返回的是一个子列表</strong>；可用逻辑向量，整数向量，字符向量提取。</li><li>使用<code>[[]]</code>从列表中提取单个元素，并非子列表。</li><li>直接使用<code>$</code>，作用相同于<code>[[]]</code>。综合使用。x[[1]][[1]]</li><li><strong>注意于tibble之间使用的异同点，tibble[1], tibble[[1]]</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a &lt;- list(a=1:3,b=&quot;a string&quot;,c=pi,d=list(-1,-5))</span><br><span class="line">a[c(1:2)]</span><br><span class="line">a[&quot;a&quot;]</span><br><span class="line">a[[&quot;a&quot;]][1:2]</span><br></pre></td></tr></table></figure><h4 id="五-特性："><a href="#五-特性：" class="headerlink" title="五. 特性："></a>五. 特性：</h4>任何向量都可以通过其特性来附加任意元数据。可以将特性看作可以附加在任何对象上的一个向量命名列表。<strong>维度、名称、类</strong>  </li></ul></li></ol><ul><li><strong>泛型函数</strong>：可以根据不同类型的输入而进行不同的操作。面向对象编程的关键。可以根据不同类型的输入而进行不同的操作。例如 <code>as.Data()</code></li></ul><h4 id="六-拓展向量："><a href="#六-拓展向量：" class="headerlink" title="六. 拓展向量："></a>六. 拓展向量：</h4><p>利用基础的原子向量和列表构建出的另外一些重要的向量类型，称为<strong>拓展向量，其具有类的附加特性</strong>。</p><ol><li>因子：在整数型向量的基础上构建的，添加了水平特征。表示<strong>有次序的分类数据</strong><code>factor(c(&quot;ef&quot;,&quot;cd&quot;,&quot;ab&quot;),levels=c(&quot;ab&quot;,&quot;cd&quot;,&quot;ef&quot;))</code></li><li>日期和日期时间：数值型的向量。</li><li>tibble：拓展的列表。</li></ol><hr><h2 id="Charpter16-purrr-Iteration"><a href="#Charpter16-purrr-Iteration" class="headerlink" title="Charpter16_purrr Iteration"></a>Charpter16_purrr Iteration</h2><p>迭代Iteration：对多个列或多个数据集进行相同的操作。两种迭代方式：</p><ul><li>命令型编程：<code>while()</code>, <code>for()</code>。</li><li>函数式编程。减少重复代码。</li></ul><h4 id="一-For循环"><a href="#一-For循环" class="headerlink" title="一. For循环"></a>一. For循环</h4><ul><li>需为输出结果分配出足够的空间。对循环效率十分重要。</li><li>涉及的函数包括 ==<code>vector(&quot;double&quot;,ncol(df))</code>, <code>seq_along(df)</code>, <code>[[]]</code>==<ol><li>output</li><li>for loop sequence</li><li>the body<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">###16.2 for循环</span><br><span class="line">require(tidyverse)</span><br><span class="line">df &lt;- tibble(a=rnorm(10),</span><br><span class="line">             b=rnorm(10),</span><br><span class="line">             c=rnorm(10),</span><br><span class="line">             d=rnorm(10))</span><br><span class="line"></span><br><span class="line">output &lt;- vector(&quot;double&quot;,ncol(df))</span><br><span class="line">output</span><br><span class="line">for (i in seq_along(df)) &#123;</span><br><span class="line">  output[i] &lt;- median(df[[i]])</span><br><span class="line">&#125;</span><br><span class="line">output</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### exercise Alice the Camel</span><br><span class="line">humps &lt;- c(&quot;five&quot;, &quot;four&quot;,&quot;three&quot;,&quot;two&quot;,&quot;one&quot;,&quot;no&quot;)</span><br><span class="line">for (i in humps) &#123;</span><br><span class="line">  cat(str_c(&quot;Alice the camel has&quot;,rep(i,3),&quot;horse&quot;,collapse = &quot;\n&quot;),&quot;\n&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h4 id="二-for循环的变体"><a href="#二-for循环的变体" class="headerlink" title="二. for循环的变体"></a>二. for循环的变体</h4><ol><li><p>修改现有对象：与自定义的函数function()一起使用。</p><ul><li>注意<strong>在循环loop中，所有for循环使用的都是<code>[[]]</code> ，明确表示是要处理单个元素。</strong></li><li><code>df[[i]] = rescale01(df[[i]])</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">### create a tibble</span><br><span class="line">df &lt;- tibble(</span><br><span class="line">  a = rnorm(10),</span><br><span class="line">  b = rnorm(10),</span><br><span class="line">  c = rnorm(10),</span><br><span class="line">  d = rnorm(10)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">### create a function</span><br><span class="line">rescale01 &lt;- function(x) &#123;</span><br><span class="line">  rng &lt;- range(x, na.rm = TRUE)</span><br><span class="line">  (x - rng[1]) / (rng[2] - rng[1])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">### use the loop</span><br><span class="line">for (i in )</span><br></pre></td></tr></table></figure></li></ul></li><li><p>循环模式：</p><ul><li>通过对<strong>数值索引</strong>进行循环，再通过x[[i]]提取相应的值。</li><li>通过对<strong>元素element索引</strong>。</li><li>通过使用<strong>名称索引</strong>：<code>for (i in names(x))</code>，需要使用元素的名称时使用。<strong>有利于图表标题和文件名</strong></li></ul></li><li><p>处理未知的输出长度。</p><ul><li><strong>应该将loop每次的结果保存再一个列表中，循环结束后再利用<code>unlist()</code> 或者<code>purrr::flatten_dbl()</code>组合成一个向量</strong></li><li>当遇到类似的问题，如生成一个很长的字符串<code>paste(out,collapse=&quot;&quot;)</code>，或是个很大的数据框 ==<code>rbind_rows()</code>, <code>unlist()</code>== 。<strong>应首先使用一个更复杂的对象来保存每次迭代的结果，最后再一次性的组合起来。</strong> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">means &lt;- c(0,1,2)</span><br><span class="line">output &lt;- double()</span><br><span class="line">for (i in seq_along(means)) &#123;</span><br><span class="line">  n &lt;- sample(100,1)</span><br><span class="line">  output &lt;- c(output,rnorm(n,mean = means[[i]])) ### 十分不高效，这里会复制上一次的所有数据。</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">##高效法 </span><br><span class="line">out &lt;- vector(&quot;list&quot;,length = length(means))</span><br><span class="line">for (i in seq_along(means))&#123;</span><br><span class="line">  n &lt;- sample(100,1)</span><br><span class="line">  out[[i]] &lt;- rnorm(n,mean = means[[i]])</span><br><span class="line">&#125;</span><br><span class="line">unlist(out)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>处理未知长度的序列。利用while循环来实现。</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for (i in seq_along(x))&#123;</span><br><span class="line">    # body</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">## equivalent to </span><br><span class="line">i &lt;- 1</span><br><span class="line">while(i &lt;= length(x))&#123;</span><br><span class="line">    # body</span><br><span class="line">    i&lt;- i + 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>Exercises</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">####exercises</span><br><span class="line"># 1.读取文件，保存在大的数据框中</span><br><span class="line">files &lt;- dir(path = &quot;.&quot;,pattern = &quot;tsv$&quot;,full.names = F) ###匹配某一路径下所有的文件。</span><br><span class="line">data_list &lt;- vector(&quot;list&quot;,length = length(files))</span><br><span class="line">for (i in seq_along(files)) &#123;</span><br><span class="line">  data_list[[i]] &lt;- read_delim(files[[i]],delim = &quot;\t&quot;)</span><br><span class="line">&#125;</span><br><span class="line">bind_rows(data_list)</span><br><span class="line"></span><br><span class="line">#2.输出所有df中数值列的均值及名称show_mean(iris)</span><br><span class="line">iris &lt;- as_tibble(iris)</span><br><span class="line">show_means &lt;- function(df,digits=2)&#123;</span><br><span class="line">  maxstr &lt;- max(str_length(names(df)))</span><br><span class="line">  for (i in names(df)) &#123;</span><br><span class="line">  if (is.numeric(df[[i]])) &#123;</span><br><span class="line">    cat(</span><br><span class="line">      str_c(str_pad(str_c(i,&quot;:&quot;),maxstr+1L,side = &quot;right&quot;),</span><br><span class="line">            format(mean(df[[i]]),digits=2,nsmall=2),</span><br><span class="line">                   sep=&quot; &quot;</span><br><span class="line">              ),</span><br><span class="line">     sep =  &quot;\n&quot;  </span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三-for循环与函数式编程"><a href="#三-for循环与函数式编程" class="headerlink" title="三. for循环与函数式编程"></a>三. for循环与函数式编程</h4><ul><li>函数式编程语言意味着可以先将for循环包装在函数中。即<strong>将函数名作为参数传入到另一个函数中</strong></li><li>利用purrr函数，可以将复杂问题解决成子问题，然后再通过管道操作将这些问题的结果组合起来。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">col_summary &lt;- function(x,fun)&#123;</span><br><span class="line">  out &lt;- vector(&quot;double&quot;,length(x))</span><br><span class="line">  for (i in seq_along(x)) &#123;</span><br><span class="line">    out[[i]]=fun(x[[i]])</span><br><span class="line">  &#125;</span><br><span class="line">  out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">## so, we can use a funtion in fun parameter.</span><br><span class="line"></span><br><span class="line">col_summary(df,median) ## calculate the median value of each column.</span><br></pre></td></tr></table></figure><h4 id="四-映射函数-The-map-function"><a href="#四-映射函数-The-map-function" class="headerlink" title="四. 映射函数 The map function."></a>四. 映射函数 The map function.</h4><p>purrr包函数<code>map()</code>(返回的是列表),<code>map_lgl()</code>,<code>map_dbl()</code>,<code>map_chr()</code>。map()第二个参数可以是<strong>公式，字符向量，整型向量</strong>，==<code>...</code>== 作为.function 的附加参数。第三个参数为第二个函数中的附加参数。例如： <code>map_dbl(df, mean, trim = 0.5)</code>。<strong>在对列表中的各个子集内部进行筛选，返回的依旧是个列表</strong></p><ol><li>快捷方式(shortcuts)：对某个数据集中的每个分组都拟合一个线性模型。类似于factor中的一些功能。<ul><li>==<code>.</code>== 作为一个代词，代表当前的列表元素。</li><li>==<code>~</code>== 作为function(x)</li><li>==<code>~.$r.squared</code>== 结合</li><li>提取命名成分<code>map_dbl(~.$r.squared)</code>, or <code>map_dbl(2)</code>循环取列表里的第2个值。</li></ul></li><li>BaseR 中的apply函数组。lapply(), sapply(), vapply()。而purrr作为Hardley开发的，具有更加一致的map_*名字和参数，<code>. ~</code>的快捷方式，并行计算，以及计算的进度条。</li><li>exercises中涉及的一些函数：<code>map(-2:2,rnorm, n=5)</code>, <code>map(1:3,rnorm,mean=10)</code>.</li><li>对操作失败的处理：<code>safely(), possibly(), quietly()</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">### split 分割出列表</span><br><span class="line">models &lt;- mtcars %&gt;% </span><br><span class="line">  split(.$cyl) %&gt;% </span><br><span class="line">  map(function(df) lm(mpg ~ wt,data=df)) ##  df是一个匿名函数，可任意命名。</span><br><span class="line">  </span><br><span class="line">## alias:</span><br><span class="line">models &lt;- mtcars %&gt;% split( .$cyl) %&gt;% map( ~ lm(mpg ~ wt,data=.))</span><br><span class="line"></span><br><span class="line">### extract the componet</span><br><span class="line">models %&gt;% </span><br><span class="line">  map(summary) %&gt;% </span><br><span class="line">  map_dbl(~.$r.squared)</span><br><span class="line">#&gt;     4     6     8 </span><br><span class="line">#&gt; 0.509 0.465 0.423</span><br><span class="line"></span><br><span class="line">map(out, ~ .[. &gt; 0.8]) ###筛选每一列中大于0.8的数据。</span><br><span class="line"></span><br><span class="line">map(df,function(xxx) length(unique(xxx))`——》`map(df, ~ length(unique(.)))</span><br></pre></td></tr></table></figure></li></ol><h4 id="五-多参数映射mapping-over-multiple-arguments"><a href="#五-多参数映射mapping-over-multiple-arguments" class="headerlink" title="五. 多参数映射mapping over multiple arguments"></a>五. 多参数映射mapping over multiple arguments</h4><ol><li><code>map2(), pmap()</code>对每一列的功能操作会涉及到多个参数时，就需要利用此函数。注意<strong>每次调用时候，发生变化的参数放在函数功能的前面位置，值保持不变的参数放在映射函数的后面；参数为list</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mu &lt;- list(5,10,-3)</span><br><span class="line">map(mu, rnorm, n=5)</span><br><span class="line">### map2 的应用</span><br><span class="line">sigma &lt;- list(1,5,10)</span><br><span class="line">map2(mu,sigma,rnorm,n=5)</span><br><span class="line">### pmap()应用，多个参数都未定，就将参数保存到大列表中</span><br><span class="line">n &lt;- list(3,5,8)</span><br><span class="line">args &lt;- list(n=n,sd=sigma,mean=mu)</span><br><span class="line">pmap(args,rnorm)</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://gitee.com/tianpeng__wang/image/raw/master/tianpeng_pic/20200904173908.png" alt=""></p><ol start="2"><li><strong>多个参数</strong> 对于<code>pmap()</code>函数，可以将多个输入列表作为参数。且多个列表的长度一样*<em>可以转换为tibble，确保每列都有名称，且与其它列具有相同的长度 *</em></li></ol><p><img src="https://gitee.com/tianpeng__wang/image/raw/master/tianpeng_pic/20200904173846.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">params &lt;- tribble(</span><br><span class="line">  ~mean, ~sd, ~n,</span><br><span class="line">    5,     1,  1,</span><br><span class="line">   10,     5,  3,</span><br><span class="line">   -3,    10,  5</span><br><span class="line">)</span><br><span class="line">params %&gt;% </span><br><span class="line">  pmap(rnorm)</span><br><span class="line">#&gt; [[1]]</span><br><span class="line">#&gt; [1] 6.02</span><br><span class="line">#&gt; </span><br><span class="line">#&gt; [[2]]</span><br><span class="line">#&gt; [1]  8.68 18.29  6.13</span><br><span class="line">#&gt; </span><br><span class="line">#&gt; [[3]]</span><br><span class="line">#&gt; [1] -12.24  -5.76  -8.93  -4.22   8.80</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>多个参数，且多个映射函数</strong>，利用<code>invoke_map()</code>函数，参数不同，甚至函数本身也不同。（invoke 调用）</li></ol><h4 id="六-游走函数，预测函数，归纳与累计"><a href="#六-游走函数，预测函数，归纳与累计" class="headerlink" title="六. 游走函数，预测函数，归纳与累计"></a>六. 游走函数，预测函数，归纳与累计</h4><ol><li>游走函数walk，输出保存多个文件时非常实用。<code>walk(), pwalk()</code>。<ul><li>例如有一个图形列表和一个文件名的向量，可以使用pwalk()将每个文件保存到相应的位置。</li></ul></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">library(ggplot2)</span><br><span class="line">plots &lt;- mtcars %&gt;% split(.$cyl) %&gt;% </span><br><span class="line">  map( ~ ggplot(data = .,mapping = aes(mpg,wt))+geom_point())</span><br><span class="line">  path=stringi::stri_c(names(plots),&quot;.pdf&quot;)</span><br><span class="line">  </span><br><span class="line">  pwalk(list(path,plots),ggsave,path=tempdir())</span><br></pre></td></tr></table></figure><ol start="2"><li><p>预测函数<code>keep(), discard()</code>函数可以保留输入中预测值为TRUE和FALSE的元素。<code>some(), every()</code>分别用来确定预测值是否对某个元素为真。<code>detect()</code>找出预测值为真的第一个元素，<code>detect_index()</code>返回找到的元素的位置。</p></li><li><p>归纳约简与累计 reduce/accumulate：复杂列表简化为一个简单列表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vs &lt;- list(c(1,2,3,4,5),</span><br><span class="line">           c(1,2,3,4),</span><br><span class="line">           c(1,2,3))</span><br><span class="line">reduce(vs,intersect)</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="charpter21-ggplot2-graphics-for-communication"><a href="#charpter21-ggplot2-graphics-for-communication" class="headerlink" title="charpter21_ggplot2(graphics for communication)"></a>charpter21_ggplot2(graphics for communication)</h2><ol><li>标签labels:<code>labs()</code><ul><li><code>title=&quot;&quot;</code> <strong>主标题</strong></li><li><code>subtitle=&quot;&quot;</code> <strong>副标题</strong>，添加附加信息；</li><li><code>caption= &quot; &quot;</code> <strong>描述数据来源</strong> 右下角添加信息</li><li><code>x=&quot; &quot;, y=&quot; &quot;</code><strong>坐标轴信息</strong></li><li><code>color= &quot;&quot;</code> <strong>图例中的标题</strong></li><li><code>x= quote()</code> <strong>坐标轴上使用数学公式</strong></li></ul></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">library(ggplot2)</span><br><span class="line">require(tidyverse)</span><br><span class="line">ggplot(mpg,aes(displ,hwy))+geom_point(aes(color=class))+labs(title = &quot;aaaaa&quot;,subtitle = &quot;bbbbb&quot;,caption = &quot;cccc &quot;,x=&quot;HWY&quot;,y=&quot;DISPL&quot;)</span><br></pre></td></tr></table></figure><ol start="2"><li><p>注释Annotation：为单个或分组的观测值添加标签。</p><ul><li><code>filter(row_number(desc(hwy))==1)</code> 筛选每个组中hwy数值最高的观测observation。</li><li><code>geom_point() + geom_text(aes(label= ),data=)</code></li><li>利用<strong>ggrepel包可以自动调整注释标签的位置</strong>  <code>geom_label_repel(aes(label=))</code></li><li><strong>将标题加在图形里的右上角角落上</strong></li><li><strong>添加参考线</strong><code>geom_hline()</code>,<code>geom_vline(size=2,color=white)</code></li><li><strong>感兴趣的点周围添加个矩形</strong> <code>geom_rect()</code></li><li><strong>绘制箭头，指向关注的数据点</strong><code>geom_segment()</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">library(ggplot2)</span><br><span class="line">library(ggrepel)</span><br><span class="line">best_in_class &lt;- mpg %&gt;% group_by(class) %&gt;% filter(row_number(desc(hwy))==1)</span><br><span class="line">ggplot(mpg,aes(displ,hwy))+geom_point(aes(color=class))+geom_text(mapping = aes(label=model),data = best_in_class)</span><br><span class="line">### 利用ggrepel用较大的空心圆来强调</span><br><span class="line">ggplot(mpg,aes(displ,hwy))+geom_point(aes(color=class))+geom_point(size=4,shape=1,data = best_in_class)+geom_label_repel(aes(label=model),data = best_in_class)</span><br><span class="line"></span><br><span class="line">### 将标题加在图形里的右上角角落上。</span><br><span class="line">label &lt;- mpg %&gt;% summarise(displ=max(displ),hwy=max(hwy),label=&quot;AAAA\nbbbbbbbb&quot;)</span><br><span class="line">ggplot(mpg,aes(displ,hwy))+geom_point()+geom_text(aes(label=label),data = label,vjust=&quot;top&quot;,hjust=&quot;right&quot;)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>标度scale:控制从数据值到图形属性的映射。scale_x（图形属性名称）_continuous()（连续型/离散型/时间/日期时间型）</p><ul><li><strong>调整坐标轴axis ticks：</strong> <strong>刻度</strong> <code>scale_y_continuous(breaks=seq(1,40,by=5))</code>,<strong>坐标轴图例项目</strong><code>scale_y_continuous(labels=NULL)</code></li><li><strong>图例legend</strong>:<code>theme(legend.position=&quot;none/right/left/top/bottom&quot;)</code>, 控制图例的显示guides(guide_legend())</li><li><strong>标度替换</strong>：对标度进行数学转换。</li><li><strong>颜色的转换</strong>：利用RColorBrewer/ggsci包,对于数量少的legend，可以添加形状映射。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ggplot(mpg,aes(displ,hwy))+geom_point(aes(color=class))+geom_smooth(se=F,color=&quot;darkgrey&quot;)+theme(legend.position = &quot;bottom&quot;)+guides(color=guide_legend(nrow = 1,override.aes = list(size=4)))</span><br></pre></td></tr></table></figure></li></ul></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">library(ggsci)</span><br><span class="line">library(RColorBrewer)</span><br><span class="line">ggplot(mpg,aes(displ,hwy))+geom_point(aes(color=drv))+scale_color_brewer(palette = &quot;Set1&quot;)</span><br><span class="line">ggplot(mpg,aes(displ,hwy))+geom_point(aes(color=drv,shape=drv))+scale_color_aaas()</span><br></pre></td></tr></table></figure><ol start="4"><li>缩放，控制图形范围。<code>coord_cartesian()</code>函数设置xlim和ylim的参数值。</li><li>主题(themes)：定制图形中的非数据元素。<code>theme_bw()</code>,<code>theme_grey()（默认）</code>,<code>theme_classic()</code>,<code>theme_light()</code></li><li>保存图形<code>ggsave()</code></li></ol>]]></content>
      
      
      <categories>
          
          <category> R </category>
          
      </categories>
      
      
        <tags>
            
            <tag> R </tag>
            
            <tag> tidyverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git_版本控制的项目流程管理</title>
      <link href="/2020/08/31/Git_%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%9A%84%E9%A1%B9%E7%9B%AE%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
      <url>/2020/08/31/Git_%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%9A%84%E9%A1%B9%E7%9B%AE%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Bioinformatics-data-skill-book-charpter-5"><a href="#Bioinformatics-data-skill-book-charpter-5" class="headerlink" title="Bioinformatics data skill book charpter 5"></a>Bioinformatics data skill book charpter 5</h1><p>working with git is fundamentally about creating and manipulating the commits(snapshots):</p><ul><li>creating commits</li><li>looking at past commits</li><li>sharing commits</li><li>comparing different commits</li></ul><p>we can create a git repository through command <code>git init</code></p><h3 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h3><p>then we can track files we want through command <code>git add README data/README</code>: TWO roles of git add:</p><ul><li>Alerting Git to start tracking untracked files (this also stages the current version of the file to be included in the next commit)</li><li>Staging changes made to an already tracked file (staged changes will be included in the next commit)</li></ul><p>we can check the status of the git repository <code>git status</code></p><p>A staged file is not only tracked, but its latest changes are staged to be included in the next commit</p><h3 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h3><p><code>git commit -m &quot;initial import&quot;</code> This command commits your staged changes to your repository with the commit message “initial import.”  Commit messages are notes to your collaborators (and yourself in the future) about what a particular commit includes</p><h3 id="git-diff-Seeing-File-Differences"><a href="#git-diff-Seeing-File-Differences" class="headerlink" title="git diff: Seeing File Differences"></a>git diff: Seeing File Differences</h3><p>shows the differences between the files in your working directory and what’s been staged.</p><ul><li>added lines will be green and deleted lines will be red.</li><li>plus+ indicate a line addition, negative indicate deletion.</li></ul><p>after we stage a file<code>git add README</code>, we can commit.If we wanted to compare what’s been staged to our last commit. <code>git diff --staged</code></p><h3 id="git-log-Seeing-the-commit-history"><a href="#git-log-Seeing-the-commit-history" class="headerlink" title="git log: Seeing the commit history"></a>git log: Seeing the commit history</h3><p>After we commit what we did to the README file, we can use the git log to visualize our chain of commits.<code>git commit -a -m &quot;added infomation about project to README&quot;</code> and then <code>git log</code>, we will see the commit changes to our repository.<br><img src="https://gitee.com/tianpeng__wang/image/raw/master/tianpeng_pic/20200820212813.png" alt=""></p><h3 id="git-mv-git-rm-Moving-and-Removing-Files"><a href="#git-mv-git-rm-Moving-and-Removing-Files" class="headerlink" title="git mv, git rm : Moving and Removing Files"></a>git mv, git rm : Moving and Removing Files</h3><p>To move or remove tracked files in Git, we need to use Git’s version of mv and rm: git mv and git rm. <code>git mv</code>, <code>git rm</code><br><img src="https://gitee.com/tianpeng__wang/image/raw/master/tianpeng_pic/20200820213457.png" alt=""></p><h3 id="gitignore-tell-git-what-to-ignore"><a href="#gitignore-tell-git-what-to-ignore" class="headerlink" title=".gitignore tell git what to ignore."></a>.gitignore tell git what to ignore.</h3><p>because <code>git status</code> keeps listing files which are not tracked, we use .gitignore file to list the untracked files/directories.<code>echo &gt;.gitignore</code> and <code>git add .gitstatus</code>.</p><p>What we should tell .gitignore to ignore? these can be solved by using a global .gitignore file to universally ignore<code>git config --global core.excludesfile ~/.gitignore_global</code></p><ul><li>large files: fastq</li><li>Intermediate fiels</li><li>Text editor temporary files</li><li>Temporary code files</li></ul><h3 id="git-reset-undoing-a-stage"><a href="#git-reset-undoing-a-stage" class="headerlink" title="git reset: undoing a stage"></a>git reset: undoing a stage</h3><p>If you accidentally stage a messy file for a commit with <code>git add</code>, you can unstage it with <code>git reset</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;TODO: ask sequencing center about adapters&quot; &gt;&gt; README.md</span><br><span class="line">git add README.md</span><br><span class="line">git status</span><br><span class="line">git reset HEAD README.md</span><br><span class="line">git status</span><br></pre></td></tr></table></figure><h3 id="git-restore-discard-changes-and-restore"><a href="#git-restore-discard-changes-and-restore" class="headerlink" title="git restore: discard changes and restore"></a>git restore: discard changes and restore</h3><hr><h2 id="Collaborating-with-Git-by-using-Github"><a href="#Collaborating-with-Git-by-using-Github" class="headerlink" title="Collaborating with Git by using Github."></a>Collaborating with Git by using Github.</h2><p>Collaborate with git, which at its core is just about sharing commits between you and your collaborators’ repositories. The basis of sharing commits in Git is the idea of a remote repository(eg. Github).  we can retrieve commits from a remote repository (<code>git pull</code>) and send commits to a remote repository (<code>git push</code>).<br><img src="https://gitee.com/tianpeng__wang/image/raw/master/tianpeng_pic/20200826152111.png" alt=""></p><p>After we create a reporitory, we can use SSH keys to authenticate youself. the <strong>SSH keys can avoid having to enter password each time</strong>.<br>Type <code>cat ~/.ssh/id_rsa.pub</code> to view your SSH keys and copy it to the Github account settings.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><h3 id="git-remote-Connecting-with-git-remotes"><a href="#git-remote-Connecting-with-git-remotes" class="headerlink" title="git remote: Connecting with git remotes"></a>git remote: Connecting with git remotes</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:wang-tianpeng/git_test.git</span><br></pre></td></tr></table></figure><p>this command enables us to specify the address of git reporitory and the remote name for it <em>origin</em>.you can add other remote repositories with different names by <code>git remote add</code>. We can type <code>git remote -v</code> to view the existing remote name. If we need to delete an unused remote repository, we can use<code>git remote rm</code></p><h3 id="git-push-Pushing-commits-to-a-remote-repository"><a href="#git-push-Pushing-commits-to-a-remote-repository" class="headerlink" title="git push Pushing commits to a remote repository."></a>git push Pushing commits to a remote repository.</h3><p>Let’s push our initial commits from zmays-snps into our remote repository on Git‐Hub. The subcommand we use here is <code>git push &lt;remote-name&gt; &lt;branch&gt;</code>. Thus, to push our zmays-snps repository’s commit. we can type:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p><em>origin</em> means your name of Github remote repository. <em>master</em> means your curent default branch name <em>master</em>.<br><img src="https://gitee.com/tianpeng__wang/image/raw/master/tianpeng_pic/20200826161811.png" alt=""></p><h3 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h3><p>Collaboration on Git is a back-and-forth exchange, where one person<br>pushes their latest commits to the remote repository, other collaborators pull changes into their local repositories, make their own changes and commits, and then push these commits to the central repository for others to see and work with.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">### we can first mimic(mimicking) a collaborator&apos;s version of the project</span><br><span class="line">git clone git@github.com:wang-tianpeng/git_test.git zmays-snps-barbara</span><br></pre></td></tr></table></figure><p>First, we can make a commit to our local repository.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;Samples expected from sequencing core 2013-01-10&quot; &gt;&gt; README.md</span><br><span class="line"></span><br><span class="line">git commit -a -m &quot;added information about samples&quot;</span><br><span class="line">git push origin master</span><br><span class="line"></span><br><span class="line">### Now in zmays-snps-barbara directory</span><br><span class="line">git pull origin master</span><br></pre></td></tr></table></figure><p>So finally, we can verify that collaborator’s repository contains the most recent commit using <code>git log</code> or even fancy command <font color=red><code>git log --pretty=oneline --abbrev-commit</code></font>. The tips for git collaborating: Pull often.</p><h3 id="Merge-Conflicts"><a href="#Merge-Conflicts" class="headerlink" title="Merge Conflicts"></a>Merge Conflicts</h3><p>Merge conflicts occur when Git can’t automatically merge your repository with the commits from the latest pull. The strategy to solve them is always the same:</p><ol><li>Use <code>git status</code> to find the conflicting files.</li><li>Open and edit those files manually to a version that fixes the confict.</li><li>Use <code>git add</code> to tell Git that you’ve solved the conflict in a particular file.</li><li>Once all conflicts are resolved, use git status to check that all changes are staged. Then, commit the resolved versions of the conflicting file(s).</li></ol><h3 id="git-shortlog"><a href="#git-shortlog" class="headerlink" title="git shortlog"></a>git shortlog</h3><hr><h2 id="Working-with-Past-Commits"><a href="#Working-with-Past-Commits" class="headerlink" title="Working with Past Commits"></a>Working with Past Commits</h2><h3 id="git-checkout-Getting-files-from-the-past"><a href="#git-checkout-Getting-files-from-the-past" class="headerlink" title="git checkout: Getting files from the past"></a>git checkout: Getting files from the past</h3><p>If you accidentially overwrite the current version of README.md, we can see this change with <code>git status</code>, We can restore this file by checking out the version in our last commit(HEAD points) with command <code>git checkout -- &lt;file&gt;</code> or <code>git restore &lt;file&gt;</code></p><p>we can restore the README to any version of history with command <code>git checkout HEAD~&lt;NUM&gt; README</code><br>or with the IDs of history version <font color=red><code>git log --pretty=oneline --abbrev-commit</code></font></p><h3 id="git-stash-Stashing-Your-Changes"><a href="#git-stash-Stashing-Your-Changes" class="headerlink" title="git stash: Stashing Your Changes"></a>git stash: Stashing Your Changes</h3><p>git stash is handy when we want to save our messy, partial progress before operations that are best performed with a clean working directory.</p><p>Stashing our working changes sets our directory to the same state it was in at the last<br>commit <code>git stash</code> and <code>git stash pop</code></p><h3 id="git-diff-Comparing-the-Commits-and-Files"><a href="#git-diff-Comparing-the-Commits-and-Files" class="headerlink" title="git diff: Comparing the Commits and Files."></a>git diff: Comparing the Commits and Files.</h3><p>We can use <code>git diff</code> to compare our current working tree to other commits and differences between Two arbitary commits. if we wanted to compare what we have now (at HEAD) to commit dafce75</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git diff dafce75</span><br><span class="line">git diff HEAD~1</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/tianpeng__wang/image/raw/master/tianpeng_pic/20200829153701.png" alt=""></p><h3 id="git-commit-–amend-Undoing-and-Editing-commits-撤回commit"><a href="#git-commit-–amend-Undoing-and-Editing-commits-撤回commit" class="headerlink" title="git commit –amend: Undoing and Editing commits.撤回commit"></a>git commit –amend: Undoing and Editing commits.撤回commit</h3><p>If we were to make a mistake in a commit message, thene we could amend our commit with.<code>git commit --amend</code>. Amending commits isn’t limited to just changing the commit message though. You can make changes to your file, stage them, and then amend these staged changes with git commit –amend.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git commit -a -m &quot;added adpters file to readme&quot;</span><br><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><hr><h2 id="Working-with-Branches"><a href="#Working-with-Branches" class="headerlink" title="Working with Branches"></a>Working with Branches</h2><p>Git’s branches are virtual, meaning that branching doesn’t require actually copying files in your repository. You can create, merge, and share branches effortlessly with Git. Git branches can be helpful in three ways:</p><ul><li>Branches allow you to experiment in your project without the risk of adversely affecting the main branch, master. We can create new branch and implement the changes <strong>while the <em>master</em> branch unaffected.</strong></li><li>We can develop new features or bug fixes without affecting <em>master</em> branch. We can then <strong>merge the completed branches into the master branch.</strong></li><li>branches simplify working collaboratively on repositories. Collaborator can work on their own separate branches.</li></ul><h3 id="git-branch-git-checkout-Creating-and-Woring-with-Branches"><a href="#git-branch-git-checkout-Creating-and-Woring-with-Branches" class="headerlink" title="git branch, git checkout: Creating and Woring with Branches."></a>git branch, git checkout: Creating and Woring with Branches.</h3><p>we can create a New git branch with command <code>git branch</code>, and switch to the branch with command <code>git checkout</code>. We can see all the branches and these last commits with command <code>git log --abbrev-commit --pretty=oneline --graph --branches -n2</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">## Creating New branch</span><br><span class="line">git branch readme-changes</span><br><span class="line">git branch</span><br><span class="line"></span><br><span class="line">## switch to new branch</span><br><span class="line">git branch readme-changes</span><br><span class="line">git branch</span><br><span class="line"></span><br><span class="line">### edit anything on the README.md and commit</span><br><span class="line">~~~~~~~</span><br><span class="line">git commit -a -m &quot;reformatted readme, added sample info&quot;</span><br><span class="line"></span><br><span class="line">### switch back to the master branch.</span><br><span class="line">git checkout master</span><br><span class="line">### check the README.md which swaps out to the version on the master.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### suppose we do sth on the master branch</span><br><span class="line">git branch</span><br><span class="line">echo &quot;&gt;adapter-1\\nGATGATCATTCAGCGACTACGATCG&quot; &gt;&gt; adapters.fa</span><br><span class="line">git add adapter.fa</span><br><span class="line">git commit -a -m &quot;added adapters file&quot;</span><br><span class="line"></span><br><span class="line">### after we switch to the branch, we will only see the branch-commited files.</span><br></pre></td></tr></table></figure><h3 id="git-merge-Merging-Branches"><a href="#git-merge-Merging-Branches" class="headerlink" title="git merge: Merging Branches"></a>git merge: Merging Branches</h3><p>First, use git checkout to switch to the branch we want to merge the other branch into. Then, use git merge <otherbranch> to merge the other branch into the current branch. if we want to merge the readme-changes branch to the master branch, we can switch to the <em>master</em> first, and merge with <code>git merge readme-changes</code>. we will find that the README.md file on the master branch was replaced by the README.md file from the branch.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git merge readme-changes</span><br><span class="line">git log --abbrev-commit --pretty=oneline --graph --branches -n 3</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/tianpeng__wang/image/raw/master/tianpeng_pic/20200831213028.png" alt=""></p><h3 id="Branches-and-Remotes"><a href="#Branches-and-Remotes" class="headerlink" title="Branches and Remotes"></a>Branches and Remotes</h3><p>If we want to see how Git’s branches and remote repositories are related, we can share our local branches with collaborators. we can <code>git branch --all</code> to show the hidden remote branches. <img src="https://gitee.com/tianpeng__wang/image/raw/master/tianpeng_pic/20200831214024.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git push origin new-methods</span><br><span class="line">git fetch origin</span><br><span class="line">git branch --all</span><br></pre></td></tr></table></figure><p><code>git pull</code> is a command combined with <code>git fetch</code> and <code>git merge</code>. So, if we want to see all the branches from the collaborators, we can use command</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin</span><br><span class="line">git branch --all</span><br></pre></td></tr></table></figure><p>git fetch doesn’t change any of your local branches; rather, it just synchronizes your<br>remote branches with the newest commits from the remote repositories. If we want to delete the local branch with command <code>git branch -d new-methods</code></p><blockquote><p>参考资料：<a href="https://oschina.gitee.io/learn-git-branching/" target="_blank" rel="noopener">https://oschina.gitee.io/learn-git-branching/</a></p></blockquote><blockquote><p>《Bioinformatics Data Skill》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Git </tag>
            
            <tag> version control </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基因流与渐渗分析——D-statistics</title>
      <link href="/2020/08/04/%E5%9F%BA%E5%9B%A0%E6%B5%81%E4%B8%8E%E6%B8%90%E6%B8%97%E5%88%86%E6%9E%90%E2%80%94%E2%80%94D-statistics/"/>
      <url>/2020/08/04/%E5%9F%BA%E5%9B%A0%E6%B5%81%E4%B8%8E%E6%B8%90%E6%B8%97%E5%88%86%E6%9E%90%E2%80%94%E2%80%94D-statistics/</url>
      
        <content type="html"><![CDATA[<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p><strong>基因渐渗(introgression)</strong>:，Introgression is the movement of a gene from one species into the gene pool of another by the repeated backcrossing of an interspecific hybrid with one of its parent species。关键点：属于<strong>两个物种之间</strong>的基因流动，通常是<strong>后代种</strong>与<strong>祖先种</strong>的反复回交实现祖先种的一些基因区段(表现为潜在的祖先性状)再次出现在后代种当中。</p><p><strong>不完全谱系分选(ILS,Incomplete Lineage sorting)</strong>:位点树（基因树）和物种树不一致的现象。例如ABC物种分化前某一位点存在多态性，为0/1。随着C分化出去，而此多态性的位点在C中发生了固定，为1，而在AB祖先中是以多态存在。当AB发生分化时，此等位以随机的方式分别进入AB物种中。当B的位点和C相同时，即发生BC关系更近的现象。我们以为是BC之间存在基因流的现象，而实际上为不完全谱系分选。</p><p><img src="https://cdn.jsdelivr.net/gh/wang-tianpeng/image_hosting/tianpeng_pic/20200804144349.png" alt="ILS"></p><p><strong>ABBA-BABA统计（D统计量）</strong>：是研究基因渐渗的经典方法。在一个给定的拓扑关系(((H1,H2),H3),H4)。H1,H2是姊妹类群(多为一个物种内的两个种群)，H3是潜在的基因渐渗来源物种，H4是外类群。假设给定祖先H4的位点为A，潜在渐渗祖先种H3位点为B。同时在H1,H2之间也存在allele的不同（AorB），则如果不存在H3的渐渗，则H1和H2的两个种群为AB或者BA的概率各为50%，而如果H3对H2存在有渐渗作用，则H2为B，H1为A的概率大于H2为A的概率。</p><p>以下即为计算D-统计量的方法，当D值为0时，表示H1,H2与H3不存在渐渗，当D大于0，则表示ABBA的情况更多，表示H2和H3之间的关系相对于H1更近，即存在于H3到H2的渐渗。反之D&lt;0 则表示H1和H3之间关系更近，存在H3向H1的渐渗。D值范围-1~1。</p><p><img src="https://cdn.jsdelivr.net/gh/wang-tianpeng/image_hosting/tianpeng_pic/20200521195712.png" alt="ABBA-BABA"><br><img src="https://cdn.jsdelivr.net/gh/wang-tianpeng/image_hosting/tianpeng_pic/20200521195734.png" alt="ABBA-BABA统计计算方法"></p><p><strong>其它统计量</strong>还包括:partition D-statistic, 以及近期较为流行的fd统计值,fdm统计值等。</p><h2 id="软件：Admixtools-admixr"><a href="#软件：Admixtools-admixr" class="headerlink" title="软件：Admixtools/admixr"></a>软件：Admixtools/admixr</h2><p>软件Admixtools[<a href="https://github.com/DReichLab/AdmixTools]为计算渐渗杂交相关统计量软件，其软件统计算法基于Patterson" target="_blank" rel="noopener">https://github.com/DReichLab/AdmixTools]为计算渐渗杂交相关统计量软件，其软件统计算法基于Patterson</a> et al. (2012) Ancient Admixture in Human History。软件主要包括6个程序：</p><ul><li><code>convertf</code>: VCF格式转换</li><li><code>qpDstat</code>: D检验，test of admixture with 4 pop</li><li><code>qp3Pop</code>: f3检验</li><li><code>qpBound</code>: estimating bounds on the admixture proportions.</li><li><code>qpF4Ratio</code>: f4检验。</li><li><code>rolloff</code>: dating admixture events.</li></ul><p>软件admixr[<a href="https://bodkan.net/admixr/articles/tutorial.html]为更好做admixtools分析的R包软件。" target="_blank" rel="noopener">https://bodkan.net/admixr/articles/tutorial.html]为更好做admixtools分析的R包软件。</a><br>软件接受EIGENSTRAT格式的数据文件，分别为<code>ind</code>, <code>snp</code>, <code>geno</code>文件。我们通常使用的vcf需要进行转换。</p><h2 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h2><h3 id="1-数据准备"><a href="#1-数据准备" class="headerlink" title="1. 数据准备"></a>1. 数据准备</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">library(admixr)</span><br><span class="line">library(tidyverse)</span><br><span class="line">download_data(dirname = &quot;.&quot;)</span><br><span class="line"></span><br><span class="line">snps &lt;- eigenstrat(&quot;snps&quot;)</span><br></pre></td></tr></table></figure><p>下载生成snps.geno, snps.ind, snps.snp。其中ind文件为3列分别为:<code>ind, sex, population</code>。而第三列population为admixr使用的一列。</p><h3 id="2-D检验"><a href="#2-D检验" class="headerlink" title="2. D检验"></a>2. D检验</h3><p><strong>ADMIXTOOLS实际计算的是BABA-ABBA的值</strong>，所以D&gt;0,表示H1和H3更为近，区别于ABBA-BABA的结果，与其相反。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pops &lt;- c(&quot;French&quot;, &quot;Sardinian&quot;, &quot;Han&quot;, &quot;Papuan&quot;, &quot;Khomani_San&quot;, &quot;Mbuti&quot;, &quot;Dinka&quot;)</span><br><span class="line">result &lt;- d(W = pops, X = &quot;Yoruba&quot;, Y = &quot;Vindija&quot;, Z = &quot;Chimp&quot;, data = snps)</span><br><span class="line">result %&gt;% ggplot(aes(fct_reorder(W, D), D, color = abs(Zscore) &gt; 2)) +</span><br><span class="line">  geom_point() +</span><br><span class="line">  geom_hline(yintercept = 0, linetype = 2) +</span><br><span class="line">  geom_errorbar(aes(ymin = D - 2 * stderr, ymax = D + 2 * stderr))</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/wang-tianpeng/image_hosting/tianpeng_pic/20200804160130.png" alt="D statistics"></p><p>结果表示Y的尼安德特人对于3个非洲群体是D值趋于0，符合null hypothesis：无基因渐渗影响；而对于其它走出非洲的族群都存在有0.03左右的D值影响。说明尼安德特人对于走出非洲的族群存在有渐渗作用。</p><h3 id="3-f4检验"><a href="#3-f4检验" class="headerlink" title="3. f4检验"></a>3. f4检验</h3><p>This is a test of whether four taxa are two pairs of sister taxa ((W,X),(Y,Z))。</p><p>f4计算公式类似于D检验：当f4值&gt;0表示存在W和Y或者X和Z之间的基因流。<br><img src="https://cdn.jsdelivr.net/gh/wang-tianpeng/image_hosting/tianpeng_pic/20200804161858.png" alt="f4"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result &lt;- f4(W = pops, X = &quot;Yoruba&quot;, Y = &quot;Vindija&quot;, Z = &quot;Chimp&quot;, data = snps)</span><br><span class="line">result</span><br></pre></td></tr></table></figure><p><strong>D检验会受到外类群H4 outgroup的真实情况影响，当H4实际和H1/H2共享较多位点时，此时任意的H3都会算出D值&gt;0的假阳性现象。因此，实际计算的过程中需要有副对照、正对照。设置一个不会发生渐渗的祖先群H3做对照。</strong></p><h3 id="4-f4-ratio检验"><a href="#4-f4-ratio检验" class="headerlink" title="4. f4-ratio检验"></a>4. f4-ratio检验</h3><p><img src="https://cdn.jsdelivr.net/gh/wang-tianpeng/image_hosting/tianpeng_pic/20200804163319.png" alt="f4-ratio"></p><p>给定D值&gt;0，H2已经受到了H3的渐渗作用影响，f4-ratio检验为探究H2受到了多少H3的血源成分。f4-ratio检验接受5个taxa：X, A, B,  C, O。The introgressed taxon “X”, its sister taxon “C”, the source of introgression “B” and its sister taxon “A”, and an outgroup “O”.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">result &lt;- f4ratio(X = pops, A = &quot;Altai&quot;, B = &quot;Vindija&quot;, C = &quot;Yoruba&quot;, O = &quot;Chimp&quot;, data = snps)</span><br><span class="line">ggplot(result, aes(fct_reorder(X, alpha), alpha, color = abs(Zscore) &gt; 2)) +</span><br><span class="line">  geom_point() +</span><br><span class="line">  geom_errorbar(aes(ymin = alpha - 2 * stderr, ymax = alpha + 2 * stderr)) +</span><br><span class="line">  geom_hline(yintercept = 0, linetype = 2) +</span><br><span class="line">  labs(y = &quot;Neandertal ancestry proportion&quot;, x = &quot;present-day individual&quot;)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/wang-tianpeng/image_hosting/tianpeng_pic/20200804171927.png" alt="f4-ratio-result"></p><p>现代走出非洲的族群普遍有2~3%的尼安德特人学院成分。并且在Papuan族群中显示了更高的Neanderthal成分，This is consistent with earlier studies that suggest additional archaic admixture events in the ancestors of present-day Papuans</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p><a href="https://www.bilibili.com/video/BV1XQ4y1N7sx?t=1864" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1XQ4y1N7sx?t=1864</a><br><a href="https://bodkan.net/admixr/articles/tutorial.html" target="_blank" rel="noopener">https://bodkan.net/admixr/articles/tutorial.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 分析教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基因渐渗 </tag>
            
            <tag> introgression </tag>
            
            <tag> 教程 </tag>
            
            <tag> D检验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pophelper-群体结构可视化学习</title>
      <link href="/2020/07/02/Pophelper-%E7%BE%A4%E4%BD%93%E7%BB%93%E6%9E%84%E5%8F%AF%E8%A7%86%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/07/02/Pophelper-%E7%BE%A4%E4%BD%93%E7%BB%93%E6%9E%84%E5%8F%AF%E8%A7%86%E5%8C%96%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="Pophelper基本说明"><a href="#Pophelper基本说明" class="headerlink" title="Pophelper基本说明"></a>Pophelper基本说明</h2><p>群体遗传下游分析中的一项常规分析即是群体结构的分层展示(STRUCTURE ANALYSIS)，不同于系统树和PCA，群体结构分层可以分断出小群体的个数，每个小群体之间的基因交流情况，甚至是小群体或者个体内的血源组成。</p><p>群体结构分层常用软件有<strong>STRUCTURE</strong>，<strong>ADMIXTURE</strong>和<strong>faststructure</strong>。STRUCTURE是群体结构分析的经典软件，但运行速度较慢。ADMIXTURE和faststructure软件等是近些年较新的软件，由于运算速度相对较快，已有了较多的引用次数。</p><p>群体结构分层的可视化展示通常是以堆叠柱状图所展示，<strong>Pophelper</strong>即是面向群体结构分层展示的强大的R包软件。</p><ul><li>主页：[<a href="http://www.royfrancis.com/pophelper/]" target="_blank" rel="noopener">http://www.royfrancis.com/pophelper/]</a></li><li>Web App(wrote by shiny) [<a href="https://roymf.shinyapps.io/structure/]" target="_blank" rel="noopener">https://roymf.shinyapps.io/structure/]</a></li><li>软件基本流程workflow：<br><img src="https://cdn.jsdelivr.net/gh/wang-tianpeng/image_hosting/tianpeng_pic/20200702161732.png" alt=""></li></ul><h2 id="使用介绍"><a href="#使用介绍" class="headerlink" title="使用介绍"></a>使用介绍</h2><h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h3><p>R version &gt;3.5</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># install the dependency packages</span><br><span class="line">install.packages(c(&quot;devtools&quot;,&quot;ggplot2&quot;,&quot;gridExtra&quot;,&quot;gtable&quot;,&quot;label.switching&quot;,&quot;tidyr&quot;),dependencies=T)</span><br><span class="line"></span><br><span class="line"># install pophelper package from GitHub</span><br><span class="line">devtools::install_github(&apos;royfrancis/pophelper&apos;)</span><br></pre></td></tr></table></figure><h3 id="2-读取文件"><a href="#2-读取文件" class="headerlink" title="2. 读取文件"></a>2. 读取文件</h3><p>Pophelper接受structure，admixture，faststructure，tess等软件的输出文件。个人较熟悉的ADMIXTURE和faststructure，其输出文件结构都是以meanQ和meanP的矩阵文件。</p><ul><li>以Admixture结果文件为示例[<a href="https://github.com/royfrancis/pophelper/tree/master/inst/files/admixture]" target="_blank" rel="noopener">https://github.com/royfrancis/pophelper/tree/master/inst/files/admixture]</a></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">library(pophelper)</span><br><span class="line">options(stringsAsFactors = F)</span><br><span class="line">dir.create(&quot;pophelper_learning&quot;)</span><br><span class="line">setwd(&quot;pophelper_learning/&quot;)</span><br><span class="line"></span><br><span class="line">### INPUT STRUCTURE RESULT FILES</span><br><span class="line">sfiles &lt;- list.files(path=system.file(&quot;files/structure&quot;,package=&quot;pophelper&quot;), full.names=T)</span><br><span class="line">slist &lt;- readQ(files=sfiles)</span><br><span class="line"></span><br><span class="line">### INPUT ADMIXTURE RESULT FILES</span><br><span class="line">alist &lt;- readQ(list.files(path=system.file(&quot;files/admixture&quot;,package=&quot;pophelper&quot;), full.names=T)</span><br></pre></td></tr></table></figure><h3 id="3-绘制最佳K值线"><a href="#3-绘制最佳K值线" class="headerlink" title="3. 绘制最佳K值线"></a>3. 绘制最佳K值线</h3><p>Pophelper中evannoMethodStructure()函数<em>仅支持对STRUCTURE的结果绘制最佳K值线</em>。其基本步骤包括三步</p><ol><li><code>tabularQ()</code>，接收读取的structure list文件</li><li><code>summariseQ()</code>，接收tabularQ返回结果</li><li><code>evannoMethodStructure()</code>，接收summ返回结果，绘制最佳K值线</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tbq &lt;- tabulateQ(slist)</span><br><span class="line">smq &lt;- summariseQ(tbq)</span><br><span class="line">evannoMethodStructure(data=sr1,exportplot=T,returnplot=T,returndata=F,basesize=12,linesize=0.7,height = 10,width = 12,outputfilename = &quot;test&quot;)</span><br></pre></td></tr></table></figure><ul><li>最佳K值线结果<br><img src="https://cdn.jsdelivr.net/gh/wang-tianpeng/image_hosting/tianpeng_pic/20200702165912.png" alt=""></li></ul><h3 id="4-绘制柱状堆叠图plotQ"><a href="#4-绘制柱状堆叠图plotQ" class="headerlink" title="4. 绘制柱状堆叠图plotQ()"></a>4. 绘制柱状堆叠图plotQ()</h3><p><img src="https://cdn.jsdelivr.net/gh/wang-tianpeng/image_hosting/tianpeng_pic/20200702175136.png" alt=""></p><p>一个plotQ包含了复杂的柱状堆叠图的参数，一些常用参数：</p><ul><li><code>imgoutput= &quot;sep&quot;/&quot;join&quot;</code> 默认sep，展示每个K值图，或者合并</li><li><code>showsp=T</code>：strip panel,展示每个K值堆叠图的标签<ul><li><code>sppos=&quot;left&quot;</code></li><li><code>splab=&quot;nameK1&quot;</code> <code>splab=paste0(&quot;K=&quot;,sapply(slist[c(1,4:8)],ncol))</code>仅显示K=num的标签</li><li><code>spbgcol=</code>..</li></ul></li><li><code>clustercol=c(&quot;#A6CEE3&quot;, &quot;#3F8EAA&quot;, &quot;#79C360&quot;.....)</code>堆叠柱状图的颜色</li><li><code>showlegend=T</code>:展示图例legend。</li><li><code>useindlab=T</code>:show individual lab 每个堆叠柱状图的label展示，需要q矩阵的rowname()。<ul><li><code>indlabsize</code>,<code>indlabcol</code></li></ul></li><li><code>sortind=&quot;all&quot;/&quot;Cluster1&quot;</code>不设置时是默认是按照样本rowname()的顺序展示堆叠图，可设置cluster排序，或者个人手动调整matrix矩阵的样本顺序</li><li><code>grplab=onelabset1</code>(group label)在底部分组展示。含有group时设置sorted会同时显示。onelabeset1为列表，其顺序同是按照meanQ矩阵的rownames()顺序来的。<ul><li><code>grpsize</code></li><li><code>grpangle=90</code>字体垂直展示</li></ul></li><li><code>panel spacer=0.3</code>对join合并图柱状堆叠图中间距离</li></ul><h3 id="5-一些群体结构图的示例"><a href="#5-一些群体结构图的示例" class="headerlink" title="5. 一些群体结构图的示例"></a>5. 一些群体结构图的示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sfiles &lt;- list.files(path=system.file(&quot;files/structure&quot;,package=&quot;pophelper&quot;), full.names=T)</span><br><span class="line">slist &lt;- readQ(files=sfiles,indlabfromfile=T)</span><br><span class="line">threelabset &lt;- read.delim(system.file(&quot;files/metadata.txt&quot;, package=&quot;pophelper&quot;), header=T,stringsAsFactors=F)</span><br><span class="line">twolabset &lt;- threelabset[,2:3] ### group label</span><br><span class="line"></span><br><span class="line">##绘图</span><br><span class="line">plotQ(slist[2:3],imgoutput=&quot;join&quot;,showindlab=T,grplab=twolabset,</span><br><span class="line">      subsetgrp=c(&quot;Brazil&quot;,&quot;Greece&quot;),selgrp=&quot;loc&quot;,ordergrp=T,showlegend=T,</span><br><span class="line">      showtitle=T,showsubtitle=T,titlelab=&quot;The Great Structure&quot;,</span><br><span class="line">      subtitlelab=&quot;The amazing population structure of your favourite organism.&quot;,</span><br><span class="line">      height=1.6,indlabsize=2.3,indlabheight=0.08,indlabspacer=-1,</span><br><span class="line">      barbordercolour=&quot;white&quot;,barbordersize=0,outputfilename=&quot;plotq&quot;,imgtype=&quot;png&quot;)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/wang-tianpeng/image_hosting/tianpeng_pic/20200703161714.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/wang-tianpeng/image_hosting/tianpeng_pic/20200703161741.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/wang-tianpeng/image_hosting/tianpeng_pic/20200703161832.png" alt=""></p><p><strong>Reference</strong><br>[<a href="http://www.royfrancis.com/pophelper/articles/index.html#plotq]" target="_blank" rel="noopener">http://www.royfrancis.com/pophelper/articles/index.html#plotq]</a></p>]]></content>
      
      
      <categories>
          
          <category> 群体遗传 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pophelper </tag>
            
            <tag> WGS </tag>
            
            <tag> 群体结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全基因组分析_基因型定相和填充(Phasing and Imputation)</title>
      <link href="/2020/06/15/%E5%85%A8%E5%9F%BA%E5%9B%A0%E7%BB%84%E5%88%86%E6%9E%90_%E5%9F%BA%E5%9B%A0%E5%9E%8B%E5%AE%9A%E7%9B%B8%E5%92%8C%E5%A1%AB%E5%85%85(Phasing%20and%20Imputation)/"/>
      <url>/2020/06/15/%E5%85%A8%E5%9F%BA%E5%9B%A0%E7%BB%84%E5%88%86%E6%9E%90_%E5%9F%BA%E5%9B%A0%E5%9E%8B%E5%AE%9A%E7%9B%B8%E5%92%8C%E5%A1%AB%E5%85%85(Phasing%20and%20Imputation)/</url>
      
        <content type="html"><![CDATA[<h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><p><strong>Phasing，基因定相/基因分型/单倍体分型</strong>：将二倍体or多倍体基因组上的等位基因，按照其亲本正确定位到父亲or母亲的染色体上，最终使得所有来自同一个亲本的等位基因都能够排列再同一条染色体中。</p><p><strong>Imputation，基因型填充</strong>。对基因型缺失的位点进行填补（Imputation）对这个位点的基因型规律进行总结，然后对缺失位点归到某类中，赋予其一个最可能的基因型。而基因型缺失missing主要有两种可能：</p><ul><li>遗传性缺失：个体遗传信息的变异而导致这个位点的DNA片段是<strong>真实的缺失</strong></li><li>技术型缺失：由于探针杂交效率低，或多是测序深度较低，导致一些位点是未被测到，不可避免会产生大量的<strong>随机缺失</strong></li></ul><h3 id="定相-amp-填充-Phasing-amp-Imputaion-的重要性"><a href="#定相-amp-填充-Phasing-amp-Imputaion-的重要性" class="headerlink" title="定相&amp;填充(Phasing &amp; Imputaion)的重要性"></a>定相&amp;填充(Phasing &amp; Imputaion)的重要性</h3><p><strong>定相Phasing</strong>：对于遗传变异的功能诠释密切相关。表现在遗传诊断需要了解基因突变的单倍型时，才能判断是否会产生临床症状。</p><ul><li>单倍型参考序列集（Reference panel）是基因型填充（imputation）所必须的数据材料。后者是基因型表型分析中不可少的环节。高质量的Reference Panel能提升关联分析的统计功效</li><li>除了Reference Panel的制造需要使用Phasing技术之外，对被研究的对象进行预先Phasing(Pre-phasing)也可以极大地提高基因型推断（Imputation）的准确性</li><li>多个位点组成的单倍型（Haplotype）而非单位点基因型，可实现群体遗传历史的推断。</li><li>可通过Phased后的家系人群单倍型序列，估算染色体重组率、重组热点等重要遗传参数；探测频发突变、选择信号以及基因表达的顺势调控</li></ul><p><strong>填充Imputation</strong>：基因型缺失造成信息丢失，对下游基因型-表型关联分析（GWAS分析，选择压力分析，QTL定位等）都会造成很大影响</p><h3 id="Phasing-amp-Imputaion常用方法"><a href="#Phasing-amp-Imputaion常用方法" class="headerlink" title="Phasing &amp; Imputaion常用方法"></a>Phasing &amp; Imputaion常用方法</h3><h4 id="1-Phasing的方法"><a href="#1-Phasing的方法" class="headerlink" title="1. Phasing的方法"></a>1. Phasing的方法</h4><p>Phasing的方法主要有三个：家系分型（Related individuals phasing）、群体LD分型（LD-phasing）和物理分型（Physical Phasing）</p><ul><li>家系分型（Related Individuals Phasing）：同时对父亲和母亲（或家族中人员）的基因组进行测序。可以推断出样本的两个单倍型。但对于个体和亲本的位点都是杂合的，不可被phasing</li><li>群体LD phasing。根据连算不平衡原理（Linkage disequilibrium）和相关数学模型推断群体中每个个体的单倍体。根据染色体未重组的连锁不平衡区块（LD-block）的关系，利用隐马模型(HMM)等算法可以反推断出个体最有可能的单倍体型。（<strong>由于这个方法需要依据群体的信息，那么它所能够Phasing的精度就会受到群体的制约，对于常见变异，如频率在5%以上的变异效果较好</strong>）</li><li>物理定相：根据自身的测序数据：因为二三代测序的reads是来自同一个染色体。根据这些小的局部来连成整体。</li></ul><h4 id="2-Impuation的方法"><a href="#2-Impuation的方法" class="headerlink" title="2. Impuation的方法"></a>2. Impuation的方法</h4><p>Imputation：分析各个区域的单倍体组成，总结这个区域的基因型规律并分类。然后再根据某样本缺失位点的其它非缺失位点，判断这个区域属于哪种单倍型，然后再根据所属的基因型来填补此缺失样本的缺失位点信息。<br><img src="https://cdn.jsdelivr.net/gh/wang-tianpeng/image_hosting/tianpeng_pic/20200615155843.png" alt="Imputation process"><br>根据多个个体构成的参考单倍型集合（Reference Haplotypes）推断整个群体的单倍型构成。再根据缺失样本有限的基因型信息（仅有3个位点），就可以判断这个样本与参考单倍型集中的哪种单倍型最为相似。</p><ul><li>对于没有参考数据集，利用群体本身的基因型数据推断缺失位点（常用于动植物研究）对低深度测序的数据进行imputation</li><li>对于人类的有参考数据集的，直接利用即可。</li></ul><h4 id="3-常用软件"><a href="#3-常用软件" class="headerlink" title="3. 常用软件"></a>3. 常用软件</h4><p>计算密集型,比如IMPUTE、 IMPUTE2、MACH、 和fastPHASE/BIMBAM。填充的过程中充分考虑到全部可以观察到的基因型信息，使得对缺失值的估算更加精确；但以上大部分软件都是针对人类的开发的。人类种群的遗传特性是个体杂合率较高、近交率低、系谱关系来源随机。很多植物，尤其作物的遗传特性则和人类相反。以玉米为例，玉米在育种过程中，会伴随大量的自交，因此纯合度较高，而且系谱关系（杂交方式）往往可控。以上针对人类学开发的软件就未必适用了。如果是遗传特性与玉米类似的植物的GBS数据，可以采用Tassel中包含的imputation模块。</p><p>计算高效型，比如PLINK、TUNA、WHAP和BEAGLE。此种算法仅仅关注与特定位点相邻的一小部分标记的基因型，因此在计算上更加快捷。表1列出了4种常见的基因型填充软件的特性</p><h3 id="实例学习"><a href="#实例学习" class="headerlink" title="实例学习"></a>实例学习</h3><p>以BEAGLE 5.1软件学习IMPUTATION。[<a href="http://faculty.washington.edu/browning/beagle/beagle.html#download]" target="_blank" rel="noopener">http://faculty.washington.edu/browning/beagle/beagle.html#download]</a></p><p>Beagle包含了利用家系（Related individual Phasing）和LD Phasing的模块, 如果输入的vcf文件是没有phasing的，会先进行定相，然后填充。下载基于JAVA</p><p><strong>beagle5.1参数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">data parameters ...</span><br><span class="line">  gt=&lt;VCF file: use GT field&gt;                        (optional)</span><br><span class="line">  ref=&lt;bref3 or VCF file with phased genotypes&gt;      (optional)</span><br><span class="line">  out=&lt;output file prefix&gt;                           (required)</span><br><span class="line">  map=&lt;PLINK map file with cM units&gt;                 (optional)</span><br><span class="line">  chrom=&lt;[chrom] or [chrom]:[start]-[end]&gt;           (optional)</span><br><span class="line">  excludesamples=&lt;file with 1 sample ID per line&gt;    (optional)</span><br><span class="line">  excludemarkers=&lt;file with 1 marker ID per line&gt;    (optional)</span><br><span class="line"></span><br><span class="line">phasing parameters ...</span><br><span class="line">  burnin=&lt;number of burnin iterations&gt;               (default=6)</span><br><span class="line">  iterations=&lt;number of phasing iterations&gt;          (default=12)</span><br><span class="line">  phase-states=&lt;model states for phasing&gt;            (default=280)</span><br><span class="line"></span><br><span class="line">imputation parameters ...</span><br><span class="line">  impute=&lt;impute ungenotyped markers (true/false)&gt;   (default=true)</span><br><span class="line">  imp-states=&lt;model states for imputation&gt;           (default=1600)</span><br><span class="line">  imp-segment=&lt;min haplotype segment length (cM)&gt;    (default=6.0)</span><br><span class="line">  imp-step=&lt;IBS step length (cM)&gt;                    (default=0.1)</span><br><span class="line">  imp-nsteps=&lt;number of IBS steps&gt;                   (default=7)</span><br><span class="line">  cluster=&lt;max cM in a marker cluster&gt;               (default=0.005)</span><br><span class="line">  ap=&lt;print posterior allele probabilities&gt;          (default=false)</span><br><span class="line">  gp=&lt;print posterior genotype probabilities&gt;        (default=false)</span><br><span class="line"></span><br><span class="line">general parameters ...</span><br><span class="line">  ne=&lt;effective population size&gt;                     (default=1000000)</span><br><span class="line">  err=&lt;allele mismatch rate&gt;                         (default: data dependent)</span><br><span class="line">  window=&lt;window length in cM&gt;                       (default=40.0)</span><br><span class="line">  overlap=&lt;window overlap in cM&gt;                     (default=4.0)</span><br><span class="line">  seed=&lt;random seed&gt;                                 (default=-99999)</span><br><span class="line">  nthreads=&lt;number of threads&gt;                       (default: machine dependent)</span><br></pre></td></tr></table></figure><p><strong>实际例子</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">### 下载beagle5.1</span><br><span class="line">wget http://faculty.washington.edu/browning/beagle/beagle.18May20.d20.jar</span><br><span class="line">wget http://faculty.washington.edu/browning/beagle/bref3.18May20.d20.jar</span><br><span class="line"></span><br><span class="line">### 下载测试数据</span><br><span class="line">wget http://faculty.washington.edu/browning/beagle/test.18May20.d20.vcf.gz</span><br><span class="line">zcat test.18May20.d20.vcf.gz | cut -f1-190 | tr &apos;/&apos; &apos;|&apos; | gzip &gt; ref.18May20.d20.vcf.gz</span><br><span class="line">zcat test.18May20.d20.vcf.gz | cut -f1-9,191-200 | gzip &gt; target.18May20.d20.vcf.gz</span><br><span class="line"></span><br><span class="line">### 运行beagle软件进行imputation</span><br><span class="line">java -Xmx14256m -jar beagle.18May20.d20.jar gt=test.18May20.d20.vcf.gz out=out.gt</span><br><span class="line"></span><br><span class="line">### 提供phasing数据集ref panels</span><br><span class="line">java -jar beagle.18May20.d20.jar ref=ref.18May20.d20.vcf.gz gt=target.18May20.d20.vcf.gz out=out.ref</span><br><span class="line"></span><br><span class="line">### 对参考数据集ref构建bref3</span><br><span class="line">java -jar bref3.18May20.d20.jar ref.18May20.d20.vcf.gz &gt; ref.18May20.d20.bref3</span><br><span class="line">java -jar beagle.18May20.d20.jar ref=ref.18May20.d20.bref3 gt=target.18May20.d20.vcf.gz out=out.bref3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 参考其它文章命令行</span><br><span class="line">nohup java -Xss5m -Xmn25G -Xms100G -Xmx100G -jar soft/beagle/beagle.12Jul19.0df.jar nthreads=2 gt=172sample.recode.vcf out=172sample_out ne=172</span><br><span class="line">#可能会遇到内存溢出的报错，较花时间。</span><br></pre></td></tr></table></figure><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://www.jianshu.com/p/a30de54b83c3" target="_blank" rel="noopener">人类基因组的Phasing原理是什么？</a></p><p><a href="https://www.jianshu.com/p/c99702068b4a" target="_blank" rel="noopener">用Beagle做基因型填充（Imputation）</a></p><p><a href="https://www.omicshare.com/forum/thread-1293-1-1.html" target="_blank" rel="noopener">重测序数据中的基因型缺失以及缺失数据填充</a></p><p><a href="http://faculty.washington.edu/browning/beagle/beagle.html#download" target="_blank" rel="noopener">BEAGLE参考文档</a></p>]]></content>
      
      
      <categories>
          
          <category> 群体遗传 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基因型填充 </tag>
            
            <tag> Imputation </tag>
            
            <tag> Phasing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基因渐渗分析——introgression</title>
      <link href="/2020/05/21/%E5%9F%BA%E5%9B%A0%E6%B8%90%E6%B8%97%E5%88%86%E6%9E%90%E2%80%94%E2%80%94introgression/"/>
      <url>/2020/05/21/%E5%9F%BA%E5%9B%A0%E6%B8%90%E6%B8%97%E5%88%86%E6%9E%90%E2%80%94%E2%80%94introgression/</url>
      
        <content type="html"><![CDATA[<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p><strong>基因渐渗(introgression)</strong>:，Introgression is the movement of a gene from one species into the gene pool of another by the repeated backcrossing of an interspecific hybrid with one of its parent species。关键点：属于<strong>两个物种之间</strong>的基因流动，通常是<strong>后代种</strong>与<strong>祖先种</strong>的反复回交实现祖先种的一些基因区段(表现为潜在的祖先性状)再次出现在后代种当中。</p><p><strong>ABBA-BABA统计</strong>：也称为D统计量，是研究基因渐渗的经典方法。在一个给定的拓扑关系(((H1,H2),H3),H4)。H1,H2是姊妹类群(多为一个物种内的两个种群)，H3是潜在的基因渐渗来源物种，H4是外类群。假设祖先H4的位点为A，潜在渐渗祖先种H3位点为B，则如果不存在H3的渐渗，则H1和H2的两个种群为AB或者BA的概率各为50%，而如果H3对H2存在有渐渗作用，则H2为B，H1为A的概率大于H2为A的概率。</p><p>以下即为计算D-统计量的方法，当D值为0时，表示H1,H2与H3不存在渐渗，当D大于0，则表示ABBA的情况更多，表示H2和H3之间的关系相对于H1更近，即存在于H3到H2的渐渗。D值范围-1~1。<br><img src="https://cdn.jsdelivr.net/gh/wang-tianpeng/image_hosting/tianpeng_pic/20200521195712.png" alt="ABBA-BABA"><br><img src="https://cdn.jsdelivr.net/gh/wang-tianpeng/image_hosting/tianpeng_pic/20200521195734.png" alt="ABBA-BABA统计计算方法"></p><p><strong>其它统计量</strong>还包括:partition D-statistic, 以及近期较为流行的fd统计值,fdm统计值等。</p><h2 id="数据准备和解释"><a href="#数据准备和解释" class="headerlink" title="数据准备和解释"></a>数据准备和解释</h2><ul><li>教程数据来源于<strong>3个物种multi种群和1个外类群物种</strong>的全基因组数据(whole-genome sequencing Data)<br>3个物种Hm, Ht, Hc。这三个物种下的多个种群之间存在着同域物种分布(sympatry)，故推测存在有两个物种种群之间的杂交渐渗。</li><li>数据为高深度WGS数据，已经过过滤得到双位点的SNP位点。特定的，数据仅包括18号染色体的数据，已知此染色体上的翅膀花纹颜色基因。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/wang-tianpeng/image_hosting/tianpeng_pic/20200521195631.png" alt=""></p><ul><li>推测处于同一区域的两个物种之间存在有渐渗造成的基因流(sharing of genetic variation)，例如Hc-chi和Hm-ros等等。已知位于18号染色体上的花纹基因<em>optix</em> 受到强烈选择。在一个区域的物种或通过趋同演化(independent convergent evolution)或者适应性的渐渗作用(adaptive introgression)获得此适应性的optix基因。</li></ul><h2 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h2><h4 id="1-数据准备"><a href="#1-数据准备" class="headerlink" title="1. 数据准备"></a>1. 数据准备</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/simonhmartin/tutorials/raw/master/ABBA_BABA_windows/data/hel92.DP8HET75MP9BIminVar2.chr18.geno.gz</span><br><span class="line"></span><br><span class="line">wget https://github.com/simonhmartin/tutorials/raw/master/ABBA_BABA_windows/data/hel92.pop.txt</span><br><span class="line"></span><br><span class="line">wget https://github.com/simonhmartin/tutorials/raw/master/ABBA_BABA_windows/data/chr18.LDhelmet_MLrho.w100.tsv</span><br><span class="line"></span><br><span class="line">### 脚本</span><br><span class="line">wget https://github.com/simonhmartin/genomics_general/archive/master.zip</span><br></pre></td></tr></table></figure><h4 id="2-滑动窗口检测Sliding-window-analysis"><a href="#2-滑动窗口检测Sliding-window-analysis" class="headerlink" title="2. 滑动窗口检测Sliding window analysis"></a>2. 滑动窗口检测Sliding window analysis</h4><ul><li><p>教程中的情况为(((P1,P2),P3),O)，P1为Hm.mel(mel_mel)，检测在巴拿马地区的P2(mel_ros)是否受到同域分布的P3(cyd_chi)渐渗影响；在秘鲁地区的P2(mel_ama)是否受到P3(tim_txn)的渐渗作用两种情况的外类群O均为H.num。</p></li><li><p>ABBABABAwindows.py程序基本参数</p><ul><li><code>-g</code> 基因型geno文件。</li><li><code>-f</code> 基因型文件的类型phased,pairs,haplo,diplo</li><li><code>-P1, P2, P3, P4</code>种群的名称</li><li><code>--popFile</code>:样本-种群的说明文件</li><li><code>-w</code> window大小</li><li><code>-s</code> 步移的大小</li><li><code>-m</code> 窗口最少位点数</li><li><code>-o</code> 输出文件</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">### 巴拿马地区的渐渗检测</span><br><span class="line">python ../genomics_general-master/ABBABABAwindows.py -g hel92.DP8HET75MP9BIminVar2.chr18.geno.gz \</span><br><span class="line">-f phased \</span><br><span class="line">-P1 mel_mel -P2 mel_ros -P3 cyd_chi -O num \</span><br><span class="line">--popsFile hel92.pop.txt -w 25000 -m 250 --T 3 \</span><br><span class="line">-o hel92.DP8HET75MP9BIminVar2.chr18.ABBABABA_mel_ros_chi_num.w25m250.csv.gz</span><br><span class="line"></span><br><span class="line">### 秘鲁地区的渐渗检测</span><br><span class="line">python genomics_general-master/ABBABABAwindows.py \</span><br><span class="line">-g data/hel92.DP8HET75MP9BIminVar2.chr18.geno.gz -f phased \</span><br><span class="line">-o data/hel92.DP8HET75MP9BIminVar2.chr18.ABBABABA_mel_ama_txn_num.w25m250.csv.gz \</span><br><span class="line">-P1 mel_mel -P2 mel_ama -P3 tim_txn -O num \</span><br><span class="line">--popsFile data/hel92.pop.txt -w 25000 -m 250 --T 2</span><br></pre></td></tr></table></figure><ul><li>输出结果已包括计算的D值、fd值、fdM值<br><img src="https://cdn.jsdelivr.net/gh/wang-tianpeng/image_hosting/tianpeng_pic/20200521164617.png" alt="结果文件"></li></ul><h4 id="3-简单绘图显示D值、fd值"><a href="#3-简单绘图显示D值、fd值" class="headerlink" title="3. 简单绘图显示D值、fd值"></a>3. 简单绘图显示D值、fd值</h4><ul><li>读取文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">AB_files &lt;- c(&quot;hel92.DP8HET75MP9BIminVar2.chr18.ABBABABA_mel_ros_chi_num.w25m250.csv.gz&quot;,</span><br><span class="line">              &quot;hel92.DP8HET75MP9BIminVar2.chr18.ABBABABA_mel_ama_txn_num.w25m250.csv.gz&quot;)</span><br><span class="line">AB_tables = lapply(AB_files, read.csv)</span><br><span class="line"></span><br><span class="line">head(AB_tables[[1]])</span><br><span class="line">head(AB_tables[[2]])</span><br></pre></td></tr></table></figure><ul><li>注意，如果D值为负，则fd值是无意义的。故设置所有fd值为0，当D值为负数时。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (x in 1:length(AB_tables))&#123;</span><br><span class="line">  AB_tables[[x]]$fd = ifelse(AB_tables[[x]]$D &lt; 0, 0, AB_tables[[x]]$fd)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>简单绘图</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">par(mfrow=c(length(AB_tables), 1), mar = c(4,4,1,1))</span><br><span class="line">for (x in 1:length(AB_tables))&#123;</span><br><span class="line">  plot(AB_tables[[x]]$mid, AB_tables[[x]]$fd,</span><br><span class="line">       type = &quot;l&quot;, xlim=c(0,17e6),ylim=c(0,1),ylab=&quot;Admixture Proportion&quot;,xlab=str_c(&quot;Position&quot;,x))</span><br><span class="line">  rect(1000000,0,1250000,1, col = rgb(0.5,0,0,0.2), border=NA)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>结果解释：总体显示，在此18号染色体上存在显著的introgression。特定的，仅观察色斑基因optix附近区域，在巴拿马地区cyd_chi对mel_ros的渐渗率很低，这也体现在二者的色斑相差很大；而在秘鲁地区的tim_txn对mel_ama渐渗率很高，这也体现在二者有相似的色斑颜色。此趋同演化现象即是渐渗作用引起的。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/wang-tianpeng/image_hosting/tianpeng_pic/20200521195507.png" alt="fd_window"></p><h4 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h4><p><a href="https://github.com/simonhmartin/tutorials/blob/master/ABBA_BABA_windows/" target="_blank" rel="noopener">https://github.com/simonhmartin/tutorials/blob/master/ABBA_BABA_windows/</a> (多篇NG文献直接引用此教程方法)</p><p><a href="http://www.360doc.com/content/19/0403/22/52645714_826276681.shtml" target="_blank" rel="noopener">http://www.360doc.com/content/19/0403/22/52645714_826276681.shtml</a></p><p><a href="https://www.bilibili.com/read/cv6041247" target="_blank" rel="noopener">https://www.bilibili.com/read/cv6041247</a></p>]]></content>
      
      
      <categories>
          
          <category> 分析教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基因渐渗 </tag>
            
            <tag> introgression </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BCFtools使用说明</title>
      <link href="/2020/04/03/BCFtools%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
      <url>/2020/04/03/BCFtools%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h3 id="BCFTOOLS基本说明"><a href="#BCFTOOLS基本说明" class="headerlink" title="BCFTOOLS基本说明"></a>BCFTOOLS基本说明</h3><p>bcftools由samtools开发者Li Heng所写，主要功能为变异检测和VCF/BCF文件的各种操作。支持gz压缩和未压缩的vcf/bcf输入文件。多数情况下，输入文件vcf是需要压缩并建立索引index的。</p><h3 id="通用参数"><a href="#通用参数" class="headerlink" title="通用参数"></a>通用参数</h3><ul><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> 生信工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VCFTOOLS使用说明</title>
      <link href="/2020/04/03/VCFtools%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
      <url>/2020/04/03/VCFtools%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h3 id="VCFTOOLS基本说明"><a href="#VCFTOOLS基本说明" class="headerlink" title="VCFTOOLS基本说明"></a>VCFTOOLS基本说明</h3><p>vcftools为专门处理vcf/bcf文件而生，此工具能处理VCF数据包括：过滤(filter), ；变异位点的基本统计；数据格式的转换；多个vcf文件的比较（compare files）；集合运算。</p><p>目前常用版本v0.1.16。官方网站[<a href="https://vcftools.github.io/index.html]" target="_blank" rel="noopener">https://vcftools.github.io/index.html]</a></p><p><strong>vcftools [ –vcf/gzvcf/bcf FILE ] [ –out OUTPUT PREFIX ] [ FILTERING OPTIONS ] [ OUTPUT OPTIONS ]</strong></p><h4 id="输入参数"><a href="#输入参数" class="headerlink" title="输入参数"></a>输入参数</h4><ul><li><code>--vcf</code></li><li><code>--gzvcf</code>输入gz压缩的vcf文件</li><li><code>--bcf</code></li></ul><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><ul><li><code>-out</code> 输出文件</li><li><code>--stdout/-c</code>标准输入，可后接管道操作</li><li><code>--temp</code>指定输出目录</li></ul><h4 id="过滤参数"><a href="#过滤参数" class="headerlink" title="过滤参数"></a>过滤参数</h4><ol><li><p><strong>根据位置进行过滤</strong></p><ul><li><code>--chr</code>, <code>--not-chr</code>指定过滤选择某染色体，可多次使用</li><li><code>--from-bp INT</code>, <code>--to-bp</code>，需和–chr一起使用，指定区域</li><li><code>--positions FILE</code>,<code>--exclude-positions</code>接tab分割的多个坐标位置文件</li><li><code>--bed FILE</code>,<code>--exclude-bed</code>根据<strong>BED文件进行过滤</strong></li></ul></li><li><p><strong>根据指定ID位点过滤</strong></p><ul><li><code>--snp</code> 根据vcf文件第三列ID列的snp名进行过滤。</li><li><code>--snps FILE</code>, <code>--exclude</code>根据ID文件进行过滤</li></ul></li><li><p><strong>变异类型过滤</strong></p><ul><li><code>--keep-only-indels</code></li><li><code>--remove-indels</code>即保留或去除SNP，留下INDEL。</li></ul></li><li><p><strong>根据VCF文件第七列FILTER进行过滤</strong></p><ul><li><code>--remove-filterer-all</code>FILTER列除了PASS保留，其余都过滤</li><li><code>--keep-filtered</code>,<code>--remove-filtered</code>保留或去除特定FILTER标签。可多次使用。</li></ul></li><li><p><strong>根据vcf第八列INFO进行过滤</strong></p><ul><li><code>--keep-INFO</code></li><li><code>--remove-INFO</code>根据INFO列的指定tag进行过滤</li></ul></li><li><p><strong>根据ALLEL进行过滤</strong></p><ul><li><code>--maf</code>,<code>--max-maf</code> Minor Allele Frequency二等位基因频率进行过滤，常为–maf 0.05，保留大于0.05的。</li><li><code>--non-ref-af</code>,<code>--non-ref-ac</code>…. 保留都是ALT变异的位点。</li><li><code>--mac INT</code>,<code>--max-mac</code> 保留Minor Allel Count数大于INT数的位点</li><li><code>--min-alleles 2</code>, <code>--max-alleles 2</code>筛选保留含有2个ALT变异的位点。常用。</li></ul></li><li><p><strong>根据基因型GENOTYPE数值进行过滤</strong></p><ul><li><code>--min-meanDP</code>,<code>--max-meanDP</code>根据平均覆盖深度进行过滤。–min-meanDP 3</li><li><code>--hwe</code>哈温平衡检测，根据pvalue值进行过滤，保留值以内的。–hwe 0.01</li><li><code>--max-missing</code>常用，缺失率，0为接受完全缺失，1为接受数据全都存在。一般0.8</li><li><code>--max-missing-count INT</code>缺失的个体数目超过INT，即被过滤。</li><li><code>--phased</code> 删除unpased位点</li><li><code>--minQ</code> 保留Quality值大于INT的位点。</li></ul></li><li><p><strong>对样品个体进行过滤</strong></p><ul><li><code>--indv</code>, <code>--remove-indv</code>保留或删除指定样本</li><li><code>--keep FILE</code>,<code>--remove</code> 保留/删除多个体的文件</li><li><code>--max-indv INT</code>随机保留INT数目的样本。</li></ul></li><li><p><strong>基因型过滤</strong></p><ul><li><code>--remove-filtered-geno-all</code>, <code>--remove-filtered-geno</code> 保留/删除 FILTER FLAG的位点。</li><li><code>--minGQ</code> 删除GQ值低于数值的位点</li><li><code>--minDP</code>,<code>--maxDP</code>保留覆盖率min~max范围内的位点。</li></ul></li></ol><h4 id="计算统计参数"><a href="#计算统计参数" class="headerlink" title="计算统计参数"></a>计算统计参数</h4><ol><li><strong>输出变异位点的计算统计</strong><ul><li><code>--freq</code>, <code>--freq2</code>输出每个等位基因位点的频率。</li><li><code>--counts</code>,位点数目的统计</li></ul></li><li><strong>位点覆盖深度Depth统计</strong><ul><li><code>depth</code>输出每个个体的平均覆盖度，以idepth文件展示</li><li><code>--site-depth</code>,<code>--site-mean-depth</code>每个位点的所有个体深度</li><li><code>--geno-depth</code>每个基因型的覆盖深度文件</li></ul></li><li><strong>LD计算(Linkage Disequilibrium)</strong><ul><li><code>--hap-r2</code>同时输出r^2值, D值和D’值。传统LD值计算方法，输出hap.ld</li><li><code>--geno-r2</code>，方法同PLINK软件，计算squared correlation coefficient，输出geno.ld</li><li><code>--geno-chisq</code>, </li><li><code>--hap-r2-positions FILE</code>, <code>--geno-r2-positions FILE</code>和已有文件中的点做LD计算</li><li><code>--ld-window INT</code> LD计算的最大SNP数目，即LD-window。 <code>--ld-window-min</code>最小数目</li><li><code>--ld-window-bp INT</code> LD计算窗口的实际物理距离。<code>--ld-window-bp-min</code></li><li><code>--min-r2</code>小于r2相关系数值将不被展示</li><li><code>--interchrom-hap-r2</code>, <code>--interchrom-geno-r2</code>跨染色体的r2值计算。</li></ul></li><li><strong>Ts/Tv计算(transition/transversion )</strong><ul><li><code>TsTv INT</code> 计算INT值内的TsTv值，输出TsTv文件</li><li><code>TsTv-summary</code>TsTv值计算统计。</li><li><code>--TsTv-by-count</code>, <code>--TsTv-by-qual</code> 计算tstv率。</li><li><code>--FILTER-summary</code>添加到T值到FILTER列中</li></ul></li><li><strong>核酸多样性统计</strong><ul><li><code>--site-pi</code>计算所有位点的多样性值</li><li><code>--window-pi</code>, <code>--window-pi-step</code>计算窗口中的核酸多样性值</li></ul></li><li><strong>FST计算</strong><ul><li><code>--weir-fst-pop FILE</code>:file must contain a list of individuals (one individual per line) from the VCF file that correspond to one population，可多次，生成weir.fst文件</li><li><code>--fst-window-size</code>, <code>--fst-window-step</code> FSTc滑动窗口计算，重测序一般2kb-10kb</li></ul></li><li><strong>其它计算</strong><ul><li><code>--het</code> Calculates a measure of heterozygosity on a per-individual basis. </li><li><code>--hardy</code> 每个位点的哈温平衡计算的Pvalue。</li><li><code>--TajimaD INT</code> Tajima’s D 计算</li><li><code>--indv-freq-burden</code>：calculates the number of variants within each individual of a specific frequency.</li><li><code>--LROH</code>  Long Runs of Homozygosity</li><li><code>--relatedness</code>, <code>--relatedness2</code> 计算relatedness statistic</li><li><code>--site-quality</code>提取VCF文件中每个位点的QUAL信息</li><li><code>--missing-indv</code>计算每个样本的缺失率，输出imiss</li><li><code>--missing-site</code>计算每个位点的缺失率。</li><li><code>--SNPdensity INT</code> 一定窗口内的SNP数目和频率</li><li><code>--kept-sites</code>,<code>--remove-sites</code> 通过过滤的位点到另一文件kept.sites文件,removed.sites中</li><li><code>--singletons</code>  detailing the location of singletons</li><li><code>--hapcount BED</code> output the number of unique haplotypes within user specified bins.</li><li><code>--mendel PED</code> report mendel errors identified in trios.</li><li><code>--extract-FORMAT-info &lt;STRING&gt;</code> 提取format列中的指定TAG</li><li><code>--get-INFO &lt;string&gt;</code> 提取INFO列中信息</li></ul></li></ol><h4 id="输出格式转换"><a href="#输出格式转换" class="headerlink" title="输出格式转换"></a>输出格式转换</h4><ol><li><strong>输出参数</strong><ul><li><code>--recode</code>输出.recode.vcf新文件</li><li><code>--recode-INFO-all</code>保留所有的INFO信息</li></ul></li><li><strong>格式转换</strong><ul><li><code>--012</code> 012矩阵文件</li><li><code>--IMPUTE</code> impute文件</li><li><code>--ldhat-geno</code> <code>--ldhat</code> LDhat格式。</li><li><code>--BEAGLE-GL</code>, <code>--BEAGLE-PL</code></li><li><code>--plink</code>, <code>--plink-tped</code>, <code>--chrom-map</code>PLINK格式</li></ul></li></ol><h4 id="两个VCF文件的比较操作"><a href="#两个VCF文件的比较操作" class="headerlink" title="两个VCF文件的比较操作"></a>两个VCF文件的比较操作</h4><ol><li><strong>另外一个VCF文件的输入</strong><ul><li><code>--diff</code>,<code>--gzdiff</code>,<code>--diff-bcf</code> FILE</li><li><code>--not-chr</code>不同的chr跳过</li></ul></li><li><strong>比较参数</strong><ul><li><code>--diff-site</code> Outputs the sites that are common / unique to each file</li><li><code>--diff-indv</code> 不同的个体样本</li><li><code>--diff-site-discordance</code>, <code>--diff-indv-discordance</code>calculates discordance on a site by site basis.</li><li><code>--diff-indv-map &lt;filename&gt;</code> 指定ID文件进行比较</li><li><code>--diff-discordance-matrix</code> calculates a discordance matrix</li><li><code>--diff-switch-error</code> calculates phasing errors</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 生信工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Perl单行命令记录</title>
      <link href="/2019/12/26/Perl%E5%8D%95%E8%A1%8C%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/"/>
      <url>/2019/12/26/Perl%E5%8D%95%E8%A1%8C%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h3 id="Perl单行基本参数"><a href="#Perl单行基本参数" class="headerlink" title="Perl单行基本参数"></a>Perl单行基本参数</h3><ul><li><em><code>-e</code></em> 所有perl one-liner都需要添加的参数</li><li><em><code>-n</code></em> 将会循环读入每行文件，输出需要加‘print’</li><li><em><code>-p</code></em> 将会直接print每行</li><li><em><code>-i</code></em> 直接在源文件里进行修改了。 -i.bak 源文件备份</li><li><em><code>-l</code></em> 将会使输入字符串去掉回车符号，而输出再加上回车符号。</li><li><em><code>-a</code></em> 以空格为分割输入，并将分割的结果自动保存到@F数组中。</li><li><em><code>-F</code></em> 指定分割符号，需要与-a一起用<strong>直接加分割符号：</strong> 如perl -F:，可以使用正则表达式；可利用<code>scalar @F</code>查报错。</li></ul><p>常用<code>perl -F, -alne</code>：自动以,为分割符号，保存到数组@F中，循环读取每行并去除末位\n符号。</p><h3 id="Perl常用内置变量-predefined-variables"><a href="#Perl常用内置变量-predefined-variables" class="headerlink" title="Perl常用内置变量(predefined variables)"></a>Perl常用内置变量(predefined variables)</h3><ul><li><code>$_</code> 默认为每行的内容</li><li><code>$.</code> 为每行的行号数字，类似于awk中的<em>NR</em></li><li><code>$/</code> 输入的每行的分隔符，默认是<em>\n</em>,windows下有些文件是\n\r结尾。</li><li><code>$\</code> 输出的每行的分隔符。可指定</li><li><code>$1, $2, $3</code> 正则表达式中匹配到括号里的内容，从里往外数</li><li><code>$,</code> 标量之间的分割符号，例如<code>perl -le &#39;$,=&quot;:&quot;; print 1, 2, 3&#39;</code></li><li><code>$&quot;</code> 数组中的每个标量的分隔符，默认直接print数组是以\s空格分开。<code>perl -le &#39;$&quot;=&quot;:&quot;;@data=(1,2,3);print &quot;@data&quot;&#39;</code></li><li><code>$反引号 $&amp;, $&#39;</code>: 正则表达式中，匹配内容前、匹配内容、匹配内容后会默认赋值给这三个变量。<strong>实用</strong></li><li><code>@F</code> -a、-F参数将每行分割的内容自动加到数组@F中</li><li><code>@ARGV</code> 最常用的接受文件命令</li><li><code>%ENV</code> 系统环境中的一些变量加载到%ENV哈希中</li></ul><h3 id="间距、空行-spacing"><a href="#间距、空行-spacing" class="headerlink" title="间距、空行(spacing)"></a>间距、空行(spacing)</h3><p>对每行文件加空行：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">perl -pe <span class="string">'$\ = "\n"'</span></span><br><span class="line">perl -pe <span class="string">'$_ .="\n" unless /^$/ '</span></span><br></pre></td></tr></table></figure><p>去除空行:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">perl -<span class="keyword">ne</span> <span class="string">'print unless /^$/'</span></span><br><span class="line">perl -lne <span class="string">'print if length'</span></span><br></pre></td></tr></table></figure><hr><h3 id="对行处理：编号、计数-Numbering-、选择目标行输出"><a href="#对行处理：编号、计数-Numbering-、选择目标行输出" class="headerlink" title="对行处理：编号、计数(Numbering)、选择目标行输出"></a>对行处理：编号、计数(Numbering)、选择目标行输出</h3><p>仅对非空行计数，并显示行号：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">perl -pe <span class="string">' $_ .= "$.\t" '</span> file.txt</span><br><span class="line">perl -<span class="keyword">ne</span> <span class="string">'print ++$x . "\t$_" if /\S/'</span> file.txt</span><br></pre></td></tr></table></figure><p>输出 匹配到pattern的行，并显示行号：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">perl -<span class="keyword">ne</span> <span class="string">'print unless /pattern/'</span> file.txt <span class="comment">##除了目标匹配行</span></span><br><span class="line">perl -<span class="keyword">ne</span> <span class="string">'print "$.\t$_" if /regex/ '</span> file.txt</span><br><span class="line">perl -<span class="keyword">ne</span> <span class="string">'print ++$x."\t$_" if /reads/ '</span> test.log</span><br></pre></td></tr></table></figure><p>输出匹配到pattern行的下面的一行：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">perl -<span class="keyword">ne</span> <span class="string">' if($p=0)&#123;print; $p=0&#125; $p++ if /pattern/ '</span> file.txt</span><br><span class="line">perl -<span class="keyword">ne</span> <span class="string">'$p &amp;&amp; print &amp;&amp; ($p=0); $p++ if /pattern/'</span> file.txt</span><br><span class="line">perl -<span class="keyword">ne</span> <span class="string">'$p &amp;&amp; print; $p = /science/'</span></span><br></pre></td></tr></table></figure><p>输出匹配到/AAA/和/BBB/的行:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -<span class="keyword">ne</span> <span class="string">'/AAA/ &amp;&amp; /BBB/ &amp;&amp; print'</span></span><br></pre></td></tr></table></figure><p>输出第13行、或除了第13行；输出第13、19、50行；<strong>输出13~40行</strong></p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">perl -<span class="keyword">ne</span> <span class="string">'print if $. == 13'</span> file.txt</span><br><span class="line">perl -<span class="keyword">ne</span> <span class="string">'print if $. != 13'</span> file.txt</span><br><span class="line">perl -<span class="keyword">ne</span> <span class="string">'$. == 13 &amp;&amp; print &amp;&amp; exit'</span></span><br><span class="line"></span><br><span class="line">perl -<span class="keyword">ne</span> <span class="string">'print if $.==13 || $.==19 || $.==40'</span> file.txt</span><br><span class="line"></span><br><span class="line">perl -<span class="keyword">ne</span> <span class="string">'print if $.&gt;=13 &amp;&amp; $.&lt;=40'</span> file.txt</span><br><span class="line">perl -<span class="keyword">ne</span> <span class="string">'print if 13..40'</span> file.txt</span><br></pre></td></tr></table></figure><p>输出START和END之间的行if/unless：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -i.old -<span class="keyword">ne</span> <span class="string">'print if /^START$/ .. /^END$/'</span> foo.txt</span><br></pre></td></tr></table></figure><p><strong>输出文件第三列、5列、最后一列或者1到20列:</strong></p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">perl -F<span class="string">"\t"</span> -alne <span class="string">'print join "\t", @F[2,4,-1]'</span></span><br><span class="line">perl -F<span class="string">"\t"</span> -alne <span class="string">'print join "\t", @F[1..19]'</span></span><br></pre></td></tr></table></figure><p>仅输出奇数行、偶数行：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">perl -<span class="keyword">ne</span> <span class="string">'print if $. % 2'</span> text</span><br><span class="line">perl -<span class="keyword">ne</span> <span class="string">'print if $. %2==0'</span> text</span><br></pre></td></tr></table></figure><p><strong>仅输出文件中重复的行</strong>：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### 出现两次就输出</span></span><br><span class="line">perl -<span class="keyword">ne</span> <span class="string">'print if ++$a&#123;$_&#125; ==2'</span></span><br></pre></td></tr></table></figure><p><strong>去重复行，仅输出第一次出现的行</strong>：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -<span class="keyword">ne</span> <span class="string">' print unless $a&#123;$_&#125;++ '</span> file.txt</span><br></pre></td></tr></table></figure><h3 id="计算相关"><a href="#计算相关" class="headerlink" title="计算相关"></a>计算相关</h3><p>输出第一列数字相加之和：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -alne <span class="string">'$sum+=$F[0];END&#123;print $sum&#125;'</span> file.txt</span><br></pre></td></tr></table></figure><p>输出时间：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">perl -le <span class="string">'print scalar(localtime)'</span></span><br><span class="line">perl -le <span class="string">'print join ":", (localtime)[2,1,0] '</span></span><br></pre></td></tr></table></figure><p>输出从5~15当中的10个随机数字</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -le <span class="string">'print join ",", map &#123; int(rand(15-5))+5 &#125; 1..10'</span></span><br></pre></td></tr></table></figure><h3 id="标量文字处理相关"><a href="#标量文字处理相关" class="headerlink" title="标量文字处理相关"></a>标量文字处理相关</h3><p>输出a到zz所有字母(..的使用)</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -le <span class="string">' $,=","; print a..zz '</span> <span class="comment"># print("a".."zz")</span></span><br></pre></td></tr></table></figure><p>输出指定长度的字符(x为重复)</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -le <span class="string">'print "a"x50'</span></span><br></pre></td></tr></table></figure><p>输出从1~100的质数(grep用法)</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">perl -le <span class="string">'@even = grep &#123;$_ % 2 == 0&#125; 1..100; print "@even"'</span></span><br><span class="line"><span class="string">``</span></span><br><span class="line"></span><br><span class="line">利用<span class="keyword">tr</span>(<span class="keyword">y</span>)修改字符</span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">`perl</span></span><br><span class="line"><span class="string">perl -le '$string = "bananas"; $string =~ y/A-Za-z/N-ZA-Mn-za-m/; print $string'</span></span><br><span class="line"><span class="string">perl -lpe 'y/A-Za-z/N-ZA-Mn-za-m/' bananas.txt</span></span><br></pre></td></tr></table></figure><p>自动转换大小写字符 \u \L</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">perl -lne <span class="string">'print "\u$_"'</span></span><br><span class="line">perl -plne <span class="string">'$_=\L$_\E'</span></span><br><span class="line">perl -ple <span class="string">' s/(\w+)/\u$1/g '</span></span><br></pre></td></tr></table></figure><p>去除每行开头、结尾的空格内容<code>s///g</code></p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -ple <span class="string">' s/^\s+|\s+$//g '</span></span><br></pre></td></tr></table></figure><p>反向输出 数组的内容</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -F: -alne <span class="string">'$" = ","; print "@&#123;[reverse @F]&#125;"'</span> file.txt <span class="comment"># a:b:c:d:e</span></span><br></pre></td></tr></table></figure><p>在第N列之后添加新的一列：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -i -F<span class="string">"\t"</span> -alne <span class="string">'print join "\t", @F[0..N-1], "NEW_column", @F[N..$#F]'</span></span><br></pre></td></tr></table></figure><p>在第N行之后添加新的一行:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -pe <span class="string">'print "text\n" if $. == N; $. = 0 if eof'</span></span><br></pre></td></tr></table></figure><h3 id="生信常用perl脚本记录"><a href="#生信常用perl脚本记录" class="headerlink" title="生信常用perl脚本记录"></a>生信常用perl脚本记录</h3><p>批量根据id提取序列</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -lne <span class="string">'if($switch)&#123;if(/^&gt;/)&#123;$flag=0;m/^&gt;?(\S+).*?$/;$flag=1 if $need&#123;$1&#125;;&#125;print if $flag&#125;else&#123;m/^&gt;?(\S+).*?$/;$need&#123;$1&#125;++&#125;$switch=1 if eof(ARGV)'</span> id.txt seq.fasta &gt;seq_id.fas</span><br></pre></td></tr></table></figure><p>FastQ文件转为FastaA文件</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -e <span class="string">'&#123; while($id=&lt;&gt;) &#123; chomp $id; chomp ($seq=&lt;&gt;); &lt;&gt;; &lt;&gt;; $id=~s/^@/&gt;/;print " $id\n$seq\n"; &#125; &#125;'</span>  file.fq &gt;file.fa</span><br></pre></td></tr></table></figure><p>VCF文件中的第三列添加ID信息，以”chr:pos”命名</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -alne <span class="string">'print if/^#/;unless(/#/)&#123;$F[2]="$F[0]:$F[1]";$"="\t"; print"@F"&#125;'</span> test.vcf</span><br></pre></td></tr></table></figure><p>移动小于2000bytes的文件到另外的文件夹中</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l *xls | perl -F<span class="string">'/\s+/'</span> -alne <span class="string">'print "$F[8]\n" if $F[4] &lt; 1000'</span> |xargs -i mv &#123;&#125; ../DIR</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 脚本 </tag>
            
            <tag> Perl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全基因组分析 || 选择压力分析_基础知识</title>
      <link href="/2019/12/25/%E5%85%A8%E5%9F%BA%E5%9B%A0%E7%BB%84%E5%88%86%E6%9E%90_%E9%80%89%E6%8B%A9%E5%8E%8B%E5%8A%9B%E5%88%86%E6%9E%90/"/>
      <url>/2019/12/25/%E5%85%A8%E5%9F%BA%E5%9B%A0%E7%BB%84%E5%88%86%E6%9E%90_%E9%80%89%E6%8B%A9%E5%8E%8B%E5%8A%9B%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p><img src="https://cdn.jsdelivr.net/gh/wang-tianpeng/image_hosting/tianpeng_pic/20191216163046.png" alt="基本原理"><br>原始群体中，遗传多样性是十分高的，整个序列的核酸diversity都高。而在受到选择之后，diversity会发生波动。核酸多样性下降 可能就是由于under selection导致的。</p><p>在演化/驯化过程中，如果某一基因X占优势，即X的基因型占据主导地位，则基因X所在区域的杂合率/多样性会显著下降。<strong>本质就是 比较基因组不同区域多样性（杂合率）的变化</strong></p><ul><li>群体遗传关心的问题：<ul><li>遗传结构（phylogeny+structure）</li><li><strong>基因组上受选择区域</strong>：群体水平基因组不同位置的区域遗传多样性变化的规律（例如：Pi、Tajima’s D, Fst）</li></ul></li><li>变异类型：<ul><li>中性突变（同义、相同类型的氨基酸、不影响环境适应性）：<strong>平衡选择，这种基因型频率是大致恒定的</strong></li><li>有利突变（正选择）：<strong>选择扫荡（Selective sweep），与有利突变的中性突变的频率会显著提升</strong><br><img src="https://cdn.jsdelivr.net/gh/wang-tianpeng/image_hosting/tianpeng_pic/20191216165322.png" alt="selective sweeps"></li><li>有害突变（负选择）：<strong>背景选择（negative selection/background selection/ purifying selection）</strong> 是潜在的噪音</li></ul></li></ul><p>负选择会对正选择有一定的干扰作用，都能产生大量的低频突变，但是正选择会产生相对较多的高频突变。</p><hr><h2 id="选择压力的分析方法"><a href="#选择压力的分析方法" class="headerlink" title="选择压力的分析方法"></a>选择压力的分析方法</h2><h3 id="单群体受选择区域的检验"><a href="#单群体受选择区域的检验" class="headerlink" title="单群体受选择区域的检验"></a>单群体受选择区域的检验</h3><p><img src="https://cdn.jsdelivr.net/gh/wang-tianpeng/image_hosting/tianpeng_pic/20191216172335.png" alt="sita计算"></p><ul><li>有效群体大小、每个位点突变速率</li><li><strong>sitaW</strong>：基于全部序列内分离位点的个数（差异位点/核酸碱基的数量）；<strong>对低频的突变更加敏感。</strong></li><li><strong>pi值</strong>：计算两两序列的差异度，然后求均值。与计算的群体有关：<ul><li>群体总体的pi：计算出的pi值即代表这个小群体的pi值，核酸多样性水平的高低。</li><li>基因组序列层面做检测，检测基因组不同区域的选择压力水平，一般采取滑动窗口的方式，例如以100kb的窗口10kb步移扫描pi值均值大小，从而计算序列层面不同区域的pi值变化。将pi值最极端区域（min 1%/5%）区域就作为受选择的区域</li></ul></li><li><strong>Tajima’s D</strong>。如果某个区域的Tajima’s D值下降了，则代表这个区域可能会受到选择（但是无法区分出正负选择 （高频突变会导致Pi值上升，而低频突变会导致W值上升）<br><img src="https://cdn.jsdelivr.net/gh/wang-tianpeng/image_hosting/tianpeng_pic/20191216173316.png" alt="Tajima&#39;s D"></li><li><strong>H检验(Fay &amp; Wu)</strong>：更关注正选择的高频突变。</li></ul><h3 id="两个亚群体之间的比较"><a href="#两个亚群体之间的比较" class="headerlink" title="两个亚群体之间的比较"></a>两个亚群体之间的比较</h3><p>多样性水平在亚群间比较，一般包括线性相关分析、亚群体间的差异比较两类。动植物重测序多是后者。Fst/pi ratio基于pi值。</p><ol><li><strong>群体分化程度Fst</strong> (Fixation index): 比较两个亚群体间的Pi值和亚群体内的Pi值的差异。<ul><li>由PI值计算演变来（序列两两差异取均值）</li><li>两个亚群体在某一段seq区域的差异度。0是无差异，数值越大，则说明两个亚群体之间已经发生了明显的分化（亚群内个体相似，亚群间差异大）</li></ul></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fst=(\pi(between) - \pi(within))/ \pi(between)</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>多样性变化倍数Pi ratio</strong>：某区间在亚群间的多样性差异的倍数，简单粗暴，就关注多样性值的高低变化。<ul><li>例如野生群体A/栽培群体B；野生群体A的多样性较高，而栽培群体B的多样性较低，所以多样性降低最显著的基因组区域，就与驯化改良基因相关</li></ul></li><li>其它比较值：<strong>ROD值</strong>、<strong>XP-CLR值</strong>等。而多个品种间的比较分化差异的<strong>di值</strong></li></ol><p>一般文章中都是将单群体的（PI, TajamaD）和多群体间比较的(Fst)值结合起来使用：单群体内多样性下降，两个群体间多样性分化程度上升，从而可能是受选择基因。（多是以滑动窗口的方法50k/100k）</p><hr><h2 id="所需材料和数据"><a href="#所需材料和数据" class="headerlink" title="所需材料和数据"></a>所需材料和数据</h2><ul><li>选择多品种，保证亚群体中更多的遗传多样性能被代表，在品种内少量个体即可（8个个体+以上基本可以）。</li><li>选择WGS，而非GBS。GBS可能~10K出现次标记，而在自然群体中，LD衰减快，如到0.1仅10K，导致丢失一些区域的信息。</li><li>测序深度：后续主流是10X。8X的深度最优性价比</li></ul><blockquote><p>参考学习资料：选择压力分析 <a href="https://www.omicshare.com/class/home/index/series?id=7" target="_blank" rel="noopener">https://www.omicshare.com/class/home/index/series?id=7</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 基因组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基因组分析 </tag>
            
            <tag> 选择压力 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Daily-statistics_分位数</title>
      <link href="/2019/12/24/Daily-statistics-%E5%88%86%E4%BD%8D%E6%95%B0/"/>
      <url>/2019/12/24/Daily-statistics-%E5%88%86%E4%BD%8D%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h4 id="19-分位数相关：定义、QQ图-Quantile-Quantile-Plots-、分位数标准化-Quantile-Normalization"><a href="#19-分位数相关：定义、QQ图-Quantile-Quantile-Plots-、分位数标准化-Quantile-Normalization" class="headerlink" title="19. 分位数相关：定义、QQ图(Quantile-Quantile Plots)、分位数标准化(Quantile Normalization)"></a>19. 分位数相关：定义、QQ图(Quantile-Quantile Plots)、分位数标准化(Quantile Normalization)</h4><ol><li>分位数(quantile)定义：能把数据分成数量相等组的线。例如中位数50%median，将数据分为相等数量的组。0.25分位数，0.75分位数（1/15分位数点）。R语言中<code>quantile()</code>多种方法结果有略微差异。数据量小不用纠结</li></ol><p><img src="https://cdn.jsdelivr.net/gh/wang-tianpeng/image_hosting/tianpeng_pic/20191224144744.png" alt=""></p><ol start="2"><li><p><strong>想知道数据更接近哪一种分布，可以使用QQ图展示</strong>。<br><img src="https://cdn.jsdelivr.net/gh/wang-tianpeng/image_hosting/tianpeng_pic/20191218093848.png" alt=""><br>纵坐标为实际数据的分布，横坐标为预估分布的对应分位数点。看两者是否相吻合。</p></li><li><p>分位数标准化：例如用再芯片数据中对 去除<strong>技术误差(technical difference)（两个批次的仪器对数据产生的影响）</strong>、或者两组RNA-seq表达量数据的标准化。</p><ul><li>分位数标准化的过程：<br><img src="https://cdn.jsdelivr.net/gh/wang-tianpeng/image_hosting/tianpeng_pic/20191224151533.png" alt=""></li></ul></li></ol><p>标准化之后的数据有相同的四分位数。并保留了每组的顺序高低。</p>]]></content>
      
      
      <categories>
          
          <category> statistics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> StatQuest </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生信单行脚本记录</title>
      <link href="/2019/12/23/%E7%94%9F%E4%BF%A1%E5%8D%95%E8%A1%8C%E8%84%9A%E6%9C%AC/"/>
      <url>/2019/12/23/%E7%94%9F%E4%BF%A1%E5%8D%95%E8%A1%8C%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h3 id="awk-amp-sed-amp-perl-单行操作"><a href="#awk-amp-sed-amp-perl-单行操作" class="headerlink" title="awk &amp; sed &amp; perl 单行操作"></a>awk &amp; sed &amp; perl 单行操作</h3><ul><li>输出第五列等于,不等于abc123的行<ul><li>分隔符<code>-F,</code></li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">awk '$5 == "abc123"' file.txt</span><br><span class="line">perl -alne 'print if $F[4]=="abc123"'</span><br><span class="line"></span><br><span class="line">awk '$5 != "abc123"' file.txt</span><br><span class="line">perl -alne 'print if $F[4]!="abc123"'</span><br><span class="line"></span><br><span class="line">awk -F, '$5 =="abc123"' file.txt</span><br><span class="line">perl -F, -alne 'print if $F[4]=="abc123"'</span><br></pre></td></tr></table></figure><ul><li>输出第7列不是以字母a-f开头的行</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk '$7 !~ /^[a-f]/' file.txt</span><br><span class="line">perl -alne 'print if $F[6] !~ /^[a-f]/'</span><br></pre></td></tr></table></figure><ul><li>输出第2列的值比第5列大的行</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk '$3&gt;$5' file.txt</span><br><span class="line">perl -alne 'print if $F[2]&gt;$F[4]'</span><br></pre></td></tr></table></figure><ul><li>计算第一列的累加值，输出结果<ul><li>计算平均值</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">awk '&#123;sum+=$1&#125; END&#123;print sum&#125;' file.txt</span><br><span class="line">perl -alne ' &#123;$sum+=$F[0]&#125;; END&#123;print"$sum\n"&#125; ' file.txt</span><br><span class="line"></span><br><span class="line">awk '&#123;sum+=$1&#125; END&#123;print x/NR&#125;' file.txt</span><br></pre></td></tr></table></figure><ul><li>消除开头或结尾的 空格或制表符，去除空行</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed 's/^[\s\t]*//; s/[\s\t]*$//' file.txt</span><br><span class="line">sed '/^$//d' file.txt</span><br></pre></td></tr></table></figure><h3 id="find-xargs-sort-uniq-等"><a href="#find-xargs-sort-uniq-等" class="headerlink" title="find, xargs, sort, uniq 等"></a>find, xargs, sort, uniq 等</h3><ul><li><p>ls按照后缀名聚类显示<code>ls -X</code></p></li><li><p>查看csv/tsv文件表头有多少列（例如ncbi runinfo的表头信息）：</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat runinfo.txt | head -1 | tr '\t' '\n' |wc -l</span><br></pre></td></tr></table></figure><ul><li>从文件中随机取10行</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shuf file.txt | head -n 10</span><br></pre></td></tr></table></figure><ul><li>第二列出现最多的字符串</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cut -f 2 file.txt | sort |uniq -c |sort -k1 -nr</span><br></pre></td></tr></table></figure><ul><li>将所有.txt 文件修改为.bak(例如在对*.txt做操作之前用于文件备份)</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name "*.txt" |sed 's/\.txt$//' | xargs -i echo mv &#123;&#125;.txt &#123;&#125;.bak |sh</span><br></pre></td></tr></table></figure><ul><li>输出一个特定的行（比如 42行</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n 42p file.txt</span><br></pre></td></tr></table></figure><ul><li>通过parallel并行运行12个fastqc任务</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find 0_raw_data | parallel -j 10 "fastqc &#123;&#125; --outdir ."</span><br></pre></td></tr></table></figure><ul><li>直接定义一个extract函数，直接extract解压缩(修改.bashrc)</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">extract () &#123;</span><br><span class="line">   if [ -f $1 ] ; then</span><br><span class="line">       case $1 in</span><br><span class="line">        *.tar.bz2)      tar xvjf $1 ;;</span><br><span class="line">        *.tar.gz)       tar xvzf $1 ;;</span><br><span class="line">        *.tar.xz)       tar Jxvf $1 ;;</span><br><span class="line">        *.bz2)          bunzip2 $1 ;;</span><br><span class="line">        *.rar)          unrar x $1 ;;</span><br><span class="line">        *.gz)           gunzip $1 ;;</span><br><span class="line">        *.tar)          tar xvf $1 ;;</span><br><span class="line">        *.tbz2)         tar xvjf $1 ;;</span><br><span class="line">        *.tgz)          tar xvzf $1 ;;</span><br><span class="line">        *.zip)          unzip $1 ;;</span><br><span class="line">        *.Z)            uncompress $1 ;;</span><br><span class="line">        *.7z)           7z x $1 ;;</span><br><span class="line">        *)              echo "don't know how to extract '$1'..." ;;</span><br><span class="line">       esac</span><br><span class="line">   else</span><br><span class="line">       echo "'$1' is not a valid file!"</span><br><span class="line">   fi</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>把上次执行的命令生成一个脚本</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo "!!" &gt; foo.sh</span><br></pre></td></tr></table></figure><ul><li>反向互补序列</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 'ATTGCTATGCTNNNT' |rev |tr 'ACTG' 'TGAC'</span><br></pre></td></tr></table></figure><ul><li>更工整的输出格式</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat file.txt | column -t |less -S</span><br><span class="line">csvtk pretty ### install csvtk</span><br></pre></td></tr></table></figure><ul><li>对samtools mpileup并行化call SNP</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BAM="yourFile.bam"</span><br><span class="line">REF="reference.fasta"</span><br><span class="line">samtools view -H $BAM</span><br><span class="line">    | grep "\@SQ"</span><br><span class="line">    | sed 's/^.*SN://g'</span><br><span class="line">    | cut -f 1</span><br><span class="line">    | xargs -I &#123;&#125; -n 1 -P 24 sh -c "samtools mpileup -BQ0 -d 100000 -uf $REF -r \"&#123;&#125;\" $BAM</span><br><span class="line">    | bcftools call -cv &gt; \"&#123;&#125;\".vcf"</span><br></pre></td></tr></table></figure><ul><li>对多个tsv/csv表根据表头columns对行rows合并。类似于dplyr中的left_join()</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 合并col_names相同的表</span></span></span><br><span class="line">csvtk concat names.csv names.reorder.csv |csvtk pretty</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 忽略大小写，保留空的行，以"NA"表示</span></span></span><br><span class="line">csvtk concat names.csv names.with-unmatched-colname.csv -i -u NA | csvtk pretty</span><br></pre></td></tr></table></figure><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li>crazyhottommy/bioinformatics-one-liners: <a href="https://github.com/crazyhottommy/bioinformatics-one-liners" target="_blank" rel="noopener">https://github.com/crazyhottommy/bioinformatics-one-liners</a></li><li>stephenturner/oneliners: <a href="https://github.com/stephenturner/oneliners" target="_blank" rel="noopener">https://github.com/stephenturner/oneliners</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 脚本 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Daily-statistics_概率和似然</title>
      <link href="/2019/12/21/Daily-statistics-%E6%A6%82%E7%8E%87%E5%92%8C%E4%BC%BC%E7%84%B6/"/>
      <url>/2019/12/21/Daily-statistics-%E6%A6%82%E7%8E%87%E5%92%8C%E4%BC%BC%E7%84%B6/</url>
      
        <content type="html"><![CDATA[<h4 id="17-概率和似然-Probability-and-Likelihood"><a href="#17-概率和似然-Probability-and-Likelihood" class="headerlink" title="17. 概率和似然 Probability and Likelihood"></a>17. 概率和似然 Probability and Likelihood</h4><ol><li><p>概率就是在给定的分布情况下（固定不变fixed），一个区间内的面积即为此probability（变化的）。即 areas under a fixed distribution.<br><img src="https://cdn.jsdelivr.net/gh/wang-tianpeng/image_hosting/tianpeng_pic/20191207175856.png" alt="fig1"></p></li><li><p>在给定的数据分布点（fixed data points）下的可变化分布的Y轴值。即 y-axis values for fixed data points with distributions that can be moved.<br><img src="https://cdn.jsdelivr.net/gh/wang-tianpeng/image_hosting/tianpeng_pic/20191207180735.png" alt="fig2"></p></li></ol><h4 id="18-最大似然-Maximum-Likelihood"><a href="#18-最大似然-Maximum-Likelihood" class="headerlink" title="18. 最大似然 Maximum Likelihood"></a>18. 最大似然 Maximum Likelihood</h4><p>最大似然的目标是找到最能拟合数据分布的方法，例如已知的normal/Exponential/Gamma分布<br><img src="https://cdn.jsdelivr.net/gh/wang-tianpeng/image_hosting/tianpeng_pic/20191216220848.png" alt="fig3"><br>需要一个均值的位置点，能够最大化观测到测量重量的 似然值。均值的位置就是所有measurements的似然值能够最大。<strong>这就是估算平均值的最大似然</strong>。同理，找到能够最大化measurements的标准差的似然值。</p><h4 id="19-指数分布和其最大似然估计-The-exponential-distribution-and-its-Maximum-likelihood-estimate"><a href="#19-指数分布和其最大似然估计-The-exponential-distribution-and-its-Maximum-likelihood-estimate" class="headerlink" title="19. 指数分布和其最大似然估计(The exponential distribution and its Maximum likelihood estimate)"></a>19. 指数分布和其最大似然估计(The exponential distribution and its Maximum likelihood estimate)</h4><ol><li><p>Statistical distribution that models the time between events.(两个事件之间，时间的概率分布)</p><ul><li>一条短信收到后，再收到第二条短信的等待时间</li><li>一个视频被看过之后，下一个人再看这个视频中间所经过的时间。</li></ul></li><li><p>公式，及lambda推导的过程。在给定一组测量measurements，找到最佳的lambda，从而画出指数分布。<br><img src="https://cdn.jsdelivr.net/gh/wang-tianpeng/image_hosting/tianpeng_pic/20191219224331.png" alt="fig4"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> statistics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> statistics </tag>
            
            <tag> StatQuest </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人网站+高效图床 搭建记录</title>
      <link href="/2019/12/20/%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99-%E9%AB%98%E6%95%88%E5%9B%BE%E5%BA%8A-%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"/>
      <url>/2019/12/20/%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99-%E9%AB%98%E6%95%88%E5%9B%BE%E5%BA%8A-%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考文章：使用 Github Pages 和 Hexo 搭建自己的独立博客(<a href="https://blog.csdn.net/qq_36759224/article/details/82121420" target="_blank" rel="noopener">https://blog.csdn.net/qq_36759224/article/details/82121420</a>)<br>Github+jsDelivr+PicGo打造稳定快速、高效免费图床(<a href="https://blog.csdn.net/qq_36759224/article/details/98058240" target="_blank" rel="noopener">https://blog.csdn.net/qq_36759224/article/details/98058240</a>)<br>hexo常用命令笔记(<a href="https://segmentfault.com/a/1190000002632530" target="_blank" rel="noopener">https://segmentfault.com/a/1190000002632530</a>)<br>Hexo 博客优化之实用功能添加系列(<a href="https://itrhx.blog.csdn.net/article/details/85010191" target="_blank" rel="noopener">https://itrhx.blog.csdn.net/article/details/85010191</a>)</p></blockquote><ol><li><p>安装node.js, Git</p></li><li><p>安装Hexo</p><ul><li>安装 hexo</li><li>安装 hexo 部署到 git page 的 deployer<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir Blog</span><br><span class="line">npm install hexo-cli -g</span><br><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Hexo初始化设置</p><ul><li>Hexo 安装完成后，将会在指定文件夹中新建所需要的文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir hexo</span><br><span class="line">hexo init</span><br></pre></td></tr></table></figure></li></ul></li><li><p>本地查看效果</p><ul><li><a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generate #g</span><br><span class="line">hexo server #s</span><br></pre></td></tr></table></figure></li></ul></li><li><p>博客部署到Github上</p><ul><li>创建 New repository</li><li>配置 SSH密钥，在Blog文件夹下</li><li>Github网站配置SSH密钥</li><li>配置Hexo的_config.yml文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;wangtianpeng1994@hotmail.com&quot;</span><br><span class="line">ssh -T git@github.com</span><br><span class="line"></span><br><span class="line">git config --global user.name &quot;wang-tianpeng&quot;</span><br><span class="line">git config --global user.email &quot;wangtianpeng1994@hotmail.com&quot;</span><br><span class="line"></span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https://github.com/wang-tianpeng/wang-tianpeng.github.io</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Hexo文件夹下启动转移至Github</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure></li><li><p>在<code>\hexo\source\_posts</code>文件夹下书写markdown文档</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">hexo n &quot;文章标题&quot;</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">layout: 页面布局（配合主题文档使用）</span><br><span class="line">title: 文章名称</span><br><span class="line">date: 文章日期</span><br><span class="line">comments: 文章是否开启评论</span><br><span class="line">photos: 文章封面图（仅部分主题支持）</span><br><span class="line">tags: </span><br><span class="line">  - 文章标签一</span><br><span class="line">  - 文章标签二</span><br><span class="line">categories: 文章分类</span><br><span class="line">description: 文章描述，即要在首页显示的摘要，而非全文显示。（仅部分主题支持）</span><br><span class="line">---</span><br></pre></td></tr></table></figure></li><li><p>配置Hexo的主题</p><ul><li>找到各种主题的Github页面</li><li>在theme文件夹下 git clone</li><li>在主文件夹下配置_config.yml文件</li><li>主文件夹下 hexo g s d</li><li>各种主题：<a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a></li><li>最终在挑选之后选择了<code>Yelee</code>主题<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/theme-next/hexo-theme-next</span><br><span class="line"></span><br><span class="line">theme: hexo-theme-next</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br><span class="line"></span><br><span class="line">hexo clean ## 清楚缓存</span><br><span class="line">hexo g -d</span><br></pre></td></tr></table></figure></li></ul></li><li><p>添加页面访问统计</p><ul><li>在<code>themes/你的主题/layout/_partial/footer.ejs</code>文件下添加以下代码即可</li><li>参考网站：不蒜子统计(<a href="http://ibruce.info/2015/04/04/busuanzi/" target="_blank" rel="noopener">http://ibruce.info/2015/04/04/busuanzi/</a>)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ol><ol start="10"><li>配置网络图床<ul><li>参考<a href="https://blog.csdn.net/qq_36759224/article/details/98058240" target="_blank" rel="noopener">Github+jsDelivr+PicGo</a></li><li>Github创建新仓库reporitory</li><li>Setting中设置新的token （注意不要关闭）repo项打勾</li><li>下载PicGO</li><li>配置成功后界面如下，可设置快捷键，截图+快捷键 自动操作。速度效率都十分不错，以后不再操心图床的问题。<br><img src="https://cdn.jsdelivr.net/gh/wang-tianpeng/image_hosting/tianpeng_pic/20191221144804.png" alt=""></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
            <tag> 图床 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Daily_statistics_置信区间+Pvalue+单尾双尾P值</title>
      <link href="/2019/12/16/Daily-statistics/"/>
      <url>/2019/12/16/Daily-statistics/</url>
      
        <content type="html"><![CDATA[<h4 id="15-置信区间-Confidence-Intervals"><a href="#15-置信区间-Confidence-Intervals" class="headerlink" title="15. 置信区间 Confidence Intervals"></a>15. 置信区间 Confidence Intervals</h4><ol><li><p>bootstrap是计算置信区间的一个方法。</p></li><li><p>95%的置信区间能够覆盖95%的均值（覆盖了95%的bootstrap过程中产生的均值intervals that covers 95% of means that you calculated when you bootstrap the sample）。</p></li><li><p>95%的置信区间意味着 在这个置信区间之外发生一次事件的概率Pvalue是小于0.05<br><img src="https://cdn.jsdelivr.net/gh/wang-tianpeng/image_hosting/tianpeng_pic/20191207173822.png" alt=""></p></li><li><p>比较两组随机样本。首先对这个随机样本取Bootstrap的均值，&gt;1000次，然后比较bootstrap后均值的置信区间。如果两个样本的95%置信区间不同，则两个样本是具有统计学差异的；而如果两个样本的置信区间之间有部分重叠，则需要做T-test检验。<br><img src="https://cdn.jsdelivr.net/gh/wang-tianpeng/image_hosting/tianpeng_pic/20191207174608.png" alt=""></p></li></ol><h4 id="16-P-value值"><a href="#16-P-value值" class="headerlink" title="16. P-value值"></a>16. P-value值</h4><ol><li>Pvalue并不是完全指概率值。Pvalue is the probability that random chance generated the data, or something else that is equal or rarer.就是<strong>双尾的概率之和</strong>。例如二项分布的抛硬币实验。两次抛掷都为头（heads）的Pvalue是0.25+0.25+0.<br><img src="https://cdn.jsdelivr.net/gh/wang-tianpeng/image_hosting/tianpeng_pic/20191214161150.png" alt=""></li><li>而抛硬币5次，对于4正1反的Pvalue值。包括4正1反，1反4正，以及5正/5反的概率之和<br><img src="https://cdn.jsdelivr.net/gh/wang-tianpeng/image_hosting/tianpeng_pic/20191214161929.png" alt=""></li><li>和概率有区别。Pvalue就是衡量这个值是否有特别之处。例如得到平均值的pr为0.01，但P-value=1。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Statistics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> statistics </tag>
            
            <tag> StatQuest </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World!</title>
      <link href="/2019/11/27/Hello_World/"/>
      <url>/2019/11/27/Hello_World/</url>
      
        <content type="html"><![CDATA[<h3 id="title1"><a href="#title1" class="headerlink" title="title1"></a>title1</h3><h4 id="title-2"><a href="#title-2" class="headerlink" title="title 2"></a>title 2</h4><p><strong>bold text</strong><br><em>italy text</em></p><p><strong>New photo</strong><br><img src="https://cdn.jsdelivr.net/gh/wang-tianpeng/image_hosting/tianpeng_pic/ibcas.png" alt="test"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd</span><br><span class="line">ls</span><br><span class="line">ls -1 *.txt |xargs -i wc</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
