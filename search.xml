<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Perl单行命令记录</title>
      <link href="/2019/12/26/Perl%E5%8D%95%E8%A1%8C%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/"/>
      <url>/2019/12/26/Perl%E5%8D%95%E8%A1%8C%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h3 id="Perl单行基本参数"><a href="#Perl单行基本参数" class="headerlink" title="Perl单行基本参数"></a>Perl单行基本参数</h3><ul><li><em><code>-e</code></em> 所有perl one-liner都需要添加的参数</li><li><em><code>-n</code></em> 将会循环读入每行文件，输出需要加‘print’</li><li><em><code>-p</code></em> 将会直接print每行</li><li><em><code>-i</code></em> 直接在源文件里进行修改了。 -i.bak 源文件备份</li><li><em><code>-l</code></em> 将会使输入字符串去掉回车符号，而输出再加上回车符号。</li><li><em><code>-a</code></em> 以空格为分割输入，并将分割的结果自动保存到@F数组中。</li><li><em><code>-F</code></em> 指定分割符号，需要与-a一起用<strong>直接加分割符号：</strong> 如perl -F:，可以使用正则表达式；可利用<code>scalar @F</code>查报错。</li></ul><p>常用<code>perl -F, -alne</code>：自动以,为分割符号，保存到数组@F中，循环读取每行并去除末位\n符号。</p><h3 id="Perl常用内置变量-predefined-variables"><a href="#Perl常用内置变量-predefined-variables" class="headerlink" title="Perl常用内置变量(predefined variables)"></a>Perl常用内置变量(predefined variables)</h3><ul><li><code>$_</code> 默认为每行的内容</li><li><code>$.</code> 为每行的行号数字，类似于awk中的<em>NR</em></li><li><code>$/</code> 输入的每行的分隔符，默认是<em>\n</em>,windows下有些文件是\n\r结尾。</li><li><code>$\</code> 输出的每行的分隔符。可指定</li><li><code>$1, $2, $3</code> 正则表达式中匹配到括号里的内容，从里往外数</li><li><code>$,</code> 标量之间的分割符号，例如<code>perl -le &#39;$,=&quot;:&quot;; print 1, 2, 3&#39;</code></li><li><code>$&quot;</code> 数组中的每个标量的分隔符，默认直接print数组是以\s空格分开。<code>perl -le &#39;$&quot;=&quot;:&quot;;@data=(1,2,3);print &quot;@data&quot;&#39;</code></li><li><code>$反引号 $&amp;, $&#39;</code>: 正则表达式中，匹配内容前、匹配内容、匹配内容后会默认赋值给这三个变量。<strong>实用</strong></li><li><code>@F</code> -a、-F参数将每行分割的内容自动加到数组@F中</li><li><code>@ARGV</code> 最常用的接受文件命令</li><li><code>%ENV</code> 系统环境中的一些变量加载到%ENV哈希中</li></ul><h3 id="间距、空行-spacing"><a href="#间距、空行-spacing" class="headerlink" title="间距、空行(spacing)"></a>间距、空行(spacing)</h3><p>对每行文件加空行：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">perl -pe <span class="string">'$\ = "\n"'</span></span><br><span class="line">perl -pe <span class="string">'$_ .="\n" unless /^$/ '</span></span><br></pre></td></tr></table></figure><p>去除空行:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">perl -<span class="keyword">ne</span> <span class="string">'print unless /^$/'</span></span><br><span class="line">perl -lne <span class="string">'print if length'</span></span><br></pre></td></tr></table></figure><hr><h3 id="对行处理：编号、计数-Numbering-、选择目标行输出"><a href="#对行处理：编号、计数-Numbering-、选择目标行输出" class="headerlink" title="对行处理：编号、计数(Numbering)、选择目标行输出"></a>对行处理：编号、计数(Numbering)、选择目标行输出</h3><p>仅对非空行计数，并显示行号：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">perl -pe <span class="string">' $_ .= "$.\t" '</span> file.txt</span><br><span class="line">perl -<span class="keyword">ne</span> <span class="string">'print ++$x . "\t$_" if /\S/'</span> file.txt</span><br></pre></td></tr></table></figure><p>输出 匹配到pattern的行，并显示行号：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">perl -<span class="keyword">ne</span> <span class="string">'print unless /pattern/'</span> file.txt <span class="comment">##除了目标匹配行</span></span><br><span class="line">perl -<span class="keyword">ne</span> <span class="string">'print "$.\t$_" if /regex/ '</span> file.txt</span><br><span class="line">perl -<span class="keyword">ne</span> <span class="string">'print ++$x."\t$_" if /reads/ '</span> test.log</span><br></pre></td></tr></table></figure><p>输出匹配到pattern行的下面的一行：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">perl -<span class="keyword">ne</span> <span class="string">' if($p=0)&#123;print; $p=0&#125; $p++ if /pattern/ '</span> file.txt</span><br><span class="line">perl -<span class="keyword">ne</span> <span class="string">'$p &amp;&amp; print &amp;&amp; ($p=0); $p++ if /pattern/'</span> file.txt</span><br><span class="line">perl -<span class="keyword">ne</span> <span class="string">'$p &amp;&amp; print; $p = /science/'</span></span><br></pre></td></tr></table></figure><p>输出匹配到/AAA/和/BBB/的行:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -<span class="keyword">ne</span> <span class="string">'/AAA/ &amp;&amp; /BBB/ &amp;&amp; print'</span></span><br></pre></td></tr></table></figure><p>输出第13行、或除了第13行；输出第13、19、50行；输出13~40行</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">perl -<span class="keyword">ne</span> <span class="string">'print if $. == 13'</span> file.txt</span><br><span class="line">perl -<span class="keyword">ne</span> <span class="string">'print if $. != 13'</span> file.txt</span><br><span class="line">perl -<span class="keyword">ne</span> <span class="string">'$. == 13 &amp;&amp; print &amp;&amp; exit'</span></span><br><span class="line"></span><br><span class="line">perl -<span class="keyword">ne</span> <span class="string">'print if $.==13 || $.==19 || $.==40'</span> file.txt</span><br><span class="line"></span><br><span class="line">perl -<span class="keyword">ne</span> <span class="string">'print if $.&gt;=13 &amp;&amp; $.&lt;=40'</span> file.txt</span><br><span class="line">perl -<span class="keyword">ne</span> <span class="string">'print if 13..40'</span> file.txt</span><br></pre></td></tr></table></figure><p>仅输出奇数行、偶数行：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">perl -<span class="keyword">ne</span> <span class="string">'print if $. % 2'</span> text</span><br><span class="line">perl -<span class="keyword">ne</span> <span class="string">'print if $. %2==0'</span> text</span><br></pre></td></tr></table></figure><p><strong>仅输出文件中重复的行</strong>：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### 出现两次就输出</span></span><br><span class="line">perl -<span class="keyword">ne</span> <span class="string">'print if ++$a&#123;$_&#125; ==2'</span></span><br></pre></td></tr></table></figure><p><strong>去重复行，仅输出第一次出现的行</strong>：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -<span class="keyword">ne</span> <span class="string">' print unless $a&#123;$_&#125;++ '</span> file.txt</span><br></pre></td></tr></table></figure><h3 id="计算相关"><a href="#计算相关" class="headerlink" title="计算相关"></a>计算相关</h3><p>输出第一列数字相加之和：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -alne <span class="string">'$sum+=$F[0];END&#123;print $sum&#125;'</span> file.txt</span><br></pre></td></tr></table></figure><p>输出时间：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">perl -le <span class="string">'print scalar(localtime)'</span></span><br><span class="line">perl -le <span class="string">'print join ":", (localtime)[2,1,0] '</span></span><br></pre></td></tr></table></figure><p>输出从5~15当中的10个随机数字</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -le <span class="string">'print join ",", map &#123; int(rand(15-5))+5 &#125; 1..10'</span></span><br></pre></td></tr></table></figure><h3 id="标量文字处理相关"><a href="#标量文字处理相关" class="headerlink" title="标量文字处理相关"></a>标量文字处理相关</h3>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 脚本 </tag>
            
            <tag> Perl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全基因组分析 || 选择压力分析_基础知识</title>
      <link href="/2019/12/25/%E5%85%A8%E5%9F%BA%E5%9B%A0%E7%BB%84%E5%88%86%E6%9E%90/"/>
      <url>/2019/12/25/%E5%85%A8%E5%9F%BA%E5%9B%A0%E7%BB%84%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p><img src="https://cdn.jsdelivr.net/gh/wang-tianpeng/image_hosting/tianpeng_pic/20191216163046.png" alt="基本原理"><br>原始群体中，遗传多样性是十分高的，整个序列的核酸diversity都高。而在受到选择之后，diversity会发生波动。核酸多样性下降 可能就是由于under selection导致的。</p><p>在演化/驯化过程中，如果某一基因X占优势，即X的基因型占据主导地位，则基因X所在区域的杂合率/多样性会显著下降。<strong>本质就是 比较基因组不同区域多样性（杂合率）的变化</strong></p><ul><li>群体遗传关心的问题：<ul><li>遗传结构（phylogeny+structure）</li><li><strong>基因组上受选择区域</strong>：群体水平基因组不同位置的区域遗传多样性变化的规律（例如：Pi、Tajima’s D, Fst）</li></ul></li><li>变异类型：<ul><li>中性突变（同义、相同类型的氨基酸、不影响环境适应性）：<strong>平衡选择，这种基因型频率是大致恒定的</strong></li><li>有利突变（正选择）：<strong>选择扫荡（Selective sweep），与有利突变的中性突变的频率会显著提升</strong><br><img src="https://cdn.jsdelivr.net/gh/wang-tianpeng/image_hosting/tianpeng_pic/20191216165322.png" alt="selective sweeps"></li><li>有害突变（负选择）：<strong>背景选择（negative selection/background selection/ purifying selection）</strong> 是潜在的噪音</li></ul></li></ul><p>负选择会对正选择有一定的干扰作用，都能产生大量的低频突变，但是正选择会产生相对较多的高频突变。</p><hr><h2 id="选择压力的分析方法"><a href="#选择压力的分析方法" class="headerlink" title="选择压力的分析方法"></a>选择压力的分析方法</h2><h3 id="单群体受选择区域的检验"><a href="#单群体受选择区域的检验" class="headerlink" title="单群体受选择区域的检验"></a>单群体受选择区域的检验</h3><p><img src="https://cdn.jsdelivr.net/gh/wang-tianpeng/image_hosting/tianpeng_pic/20191216172335.png" alt="sita计算"></p><ul><li>有效群体大小、每个位点突变速率</li><li><strong>sitaW</strong>：基于全部序列内分离位点的个数（差异位点/核酸碱基的数量）；<strong>对低频的突变更加敏感。</strong></li><li><strong>pi值</strong>：计算两两序列的差异度，然后求均值。与计算的群体有关：<ul><li>群体总体的pi：计算出的pi值即代表这个小群体的pi值，核酸多样性水平的高低。</li><li>基因组序列层面做检测，检测基因组不同区域的选择压力水平，一般采取滑动窗口的方式，例如以100kb的窗口10kb步移扫描pi值均值大小，从而计算序列层面不同区域的pi值变化。将pi值最极端区域（min 1%/5%）区域就作为受选择的区域</li></ul></li><li><strong>Tajima’s D</strong>。如果某个区域的Tajima’s D值下降了，则代表这个区域可能会受到选择（但是无法区分出正负选择 （高频突变会导致Pi值上升，而低频突变会导致W值上升）<br><img src="https://cdn.jsdelivr.net/gh/wang-tianpeng/image_hosting/tianpeng_pic/20191216173316.png" alt="Tajima&#39;s D"></li><li><strong>H检验(Fay &amp; Wu)</strong>：更关注正选择的高频突变。</li></ul><h3 id="两个亚群体之间的比较"><a href="#两个亚群体之间的比较" class="headerlink" title="两个亚群体之间的比较"></a>两个亚群体之间的比较</h3><p>多样性水平在亚群间比较，一般包括线性相关分析、亚群体间的差异比较两类。动植物重测序多是后者。Fst/pi ratio基于pi值。</p><ol><li><strong>群体分化程度Fst</strong> (Fixation index): 比较两个亚群体间的Pi值和亚群体内的Pi值的差异。<ul><li>由PI值计算演变来（序列两两差异取均值）</li><li>两个亚群体在某一段seq区域的差异度。0是无差异，数值越大，则说明两个亚群体之间已经发生了明显的分化（亚群内个体相似，亚群间差异大）</li></ul></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fst=(\pi(between) - \pi(within))/ \pi(between)</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>多样性变化倍数Pi ratio</strong>：某区间在亚群间的多样性差异的倍数，简单粗暴，就关注多样性值的高低变化。<ul><li>例如野生群体A/栽培群体B；野生群体A的多样性较高，而栽培群体B的多样性较低，所以多样性降低最显著的基因组区域，就与驯化改良基因相关</li></ul></li><li>其它比较值：<strong>ROD值</strong>、<strong>XP-CLR值</strong>等。而多个品种间的比较分化差异的<strong>di值</strong></li></ol><p>一般文章中都是将单群体的（PI, TajamaD）和多群体间比较的(Fst)值结合起来使用：单群体内多样性下降，两个群体间多样性分化程度上升，从而可能是受选择基因。（多是以滑动窗口的方法50k/100k）</p><hr><h2 id="所需材料和数据"><a href="#所需材料和数据" class="headerlink" title="所需材料和数据"></a>所需材料和数据</h2><ul><li>选择多品种，保证亚群体中更多的遗传多样性能被代表，在品种内少量个体即可（8个个体+以上基本可以）。</li><li>选择WGS，而非GBS。GBS可能~10K出现次标记，而在自然群体中，LD衰减快，如到0.1仅10K，导致丢失一些区域的信息。</li><li>测序深度：后续主流是10X。8X的深度最优性价比</li></ul><blockquote><p>参考学习资料：选择压力分析(<a href="https://www.omicshare.com/class/home/index/series?id=7" target="_blank" rel="noopener">https://www.omicshare.com/class/home/index/series?id=7</a>)</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 基因组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基因组分析 </tag>
            
            <tag> 选择压力 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Daily-statistics_分位数</title>
      <link href="/2019/12/24/Daily-statistics-%E5%88%86%E4%BD%8D%E6%95%B0/"/>
      <url>/2019/12/24/Daily-statistics-%E5%88%86%E4%BD%8D%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h4 id="19-分位数相关：定义、QQ图-Quantile-Quantile-Plots-、分位数标准化-Quantile-Normalization"><a href="#19-分位数相关：定义、QQ图-Quantile-Quantile-Plots-、分位数标准化-Quantile-Normalization" class="headerlink" title="19. 分位数相关：定义、QQ图(Quantile-Quantile Plots)、分位数标准化(Quantile Normalization)"></a>19. 分位数相关：定义、QQ图(Quantile-Quantile Plots)、分位数标准化(Quantile Normalization)</h4><ol><li>分位数(quantile)定义：能把数据分成数量相等组的线。例如中位数50%median，将数据分为相等数量的组。0.25分位数，0.75分位数（1/15分位数点）。R语言中<code>quantile()</code>多种方法结果有略微差异。数据量小不用纠结</li></ol><p><img src="https://cdn.jsdelivr.net/gh/wang-tianpeng/image_hosting/tianpeng_pic/20191224144744.png" alt=""></p><ol start="2"><li><p><strong>想知道数据更接近哪一种分布，可以使用QQ图展示</strong>。<br><img src="https://cdn.jsdelivr.net/gh/wang-tianpeng/image_hosting/tianpeng_pic/20191218093848.png" alt=""><br>纵坐标为实际数据的分布，横坐标为预估分布的对应分位数点。看两者是否相吻合。</p></li><li><p>分位数标准化：例如用再芯片数据中对 去除<strong>技术误差(technical difference)（两个批次的仪器对数据产生的影响）</strong>、或者两组RNA-seq表达量数据的标准化。</p><ul><li>分位数标准化的过程：<br><img src="https://cdn.jsdelivr.net/gh/wang-tianpeng/image_hosting/tianpeng_pic/20191224151533.png" alt=""></li></ul></li></ol><p>标准化之后的数据有相同的四分位数。并保留了每组的顺序高低。</p>]]></content>
      
      
      <categories>
          
          <category> statistics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> StatQuest </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生信单行脚本记录</title>
      <link href="/2019/12/23/%E7%94%9F%E4%BF%A1%E5%8D%95%E8%A1%8C%E8%84%9A%E6%9C%AC/"/>
      <url>/2019/12/23/%E7%94%9F%E4%BF%A1%E5%8D%95%E8%A1%8C%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h3 id="awk-amp-sed-amp-perl-单行操作"><a href="#awk-amp-sed-amp-perl-单行操作" class="headerlink" title="awk &amp; sed &amp; perl 单行操作"></a>awk &amp; sed &amp; perl 单行操作</h3><ul><li>输出第五列等于,不等于abc123的行<ul><li>分隔符<code>-F,</code></li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">awk '$5 == "abc123"' file.txt</span><br><span class="line">perl -alne 'print if $F[4]=="abc123"'</span><br><span class="line"></span><br><span class="line">awk '$5 != "abc123"' file.txt</span><br><span class="line">perl -alne 'print if $F[4]!="abc123"'</span><br><span class="line"></span><br><span class="line">awk -F, '$5 =="abc123"' file.txt</span><br><span class="line">perl -F, -alne 'print if $F[4]=="abc123"'</span><br></pre></td></tr></table></figure><ul><li>输出第7列不是以字母a-f开头的行</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk '$7 !~ /^[a-f]/' file.txt</span><br><span class="line">perl -alne 'print if $F[6] !~ /^[a-f]/'</span><br></pre></td></tr></table></figure><ul><li>输出第2列的值比第5列大的行</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk '$3&gt;$5' file.txt</span><br><span class="line">perl -alne 'print if $F[2]&gt;$F[4]'</span><br></pre></td></tr></table></figure><ul><li>计算第一列的累加值，输出结果<ul><li>计算平均值</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">awk '&#123;sum+=$1&#125; END&#123;print sum&#125;' file.txt</span><br><span class="line">perl -alne ' &#123;$sum+=$F[0]&#125;; END&#123;print"$sum\n"&#125; ' file.txt</span><br><span class="line"></span><br><span class="line">awk '&#123;sum+=$1&#125; END&#123;print x/NR&#125;' file.txt</span><br></pre></td></tr></table></figure><ul><li>消除开头或结尾的 空格或制表符，去除空行</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed 's/^[\s\t]*//; s/[\s\t]*$//' file.txt</span><br><span class="line">sed '/^$//d' file.txt</span><br></pre></td></tr></table></figure><h3 id="find-xargs-sort-uniq-等"><a href="#find-xargs-sort-uniq-等" class="headerlink" title="find, xargs, sort, uniq 等"></a>find, xargs, sort, uniq 等</h3><ul><li><p>ls按照后缀名聚类显示<code>ls -X</code></p></li><li><p>查看csv/tsv文件表头有多少列（例如ncbi runinfo的表头信息）：</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat runinfo.txt | head -1 | tr '\t' '\n' |wc -l</span><br></pre></td></tr></table></figure><ul><li>从文件中随机取10行</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shuf file.txt | head -n 10</span><br></pre></td></tr></table></figure><ul><li>第二列出现最多的字符串</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cut -f 2 file.txt | sort |uniq -c |sort -k1 -nr</span><br></pre></td></tr></table></figure><ul><li>将所有.txt 文件修改为.bak(例如在对*.txt做操作之前用于文件备份)</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name "*.txt" |sed 's/\.txt$//' | xargs -i echo mv &#123;&#125;.txt &#123;&#125;.bak |sh</span><br></pre></td></tr></table></figure><ul><li>输出一个特定的行（比如 42行</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n 42p file.txt</span><br></pre></td></tr></table></figure><ul><li>通过parallel并行运行12个fastqc任务</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find 0_raw_data | parallel -j 10 "fastqc &#123;&#125; --outdir ."</span><br></pre></td></tr></table></figure><ul><li>直接定义一个extract函数，直接extract解压缩(修改.bashrc)</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">extract () &#123;</span><br><span class="line">   if [ -f $1 ] ; then</span><br><span class="line">       case $1 in</span><br><span class="line">        *.tar.bz2)      tar xvjf $1 ;;</span><br><span class="line">        *.tar.gz)       tar xvzf $1 ;;</span><br><span class="line">        *.tar.xz)       tar Jxvf $1 ;;</span><br><span class="line">        *.bz2)          bunzip2 $1 ;;</span><br><span class="line">        *.rar)          unrar x $1 ;;</span><br><span class="line">        *.gz)           gunzip $1 ;;</span><br><span class="line">        *.tar)          tar xvf $1 ;;</span><br><span class="line">        *.tbz2)         tar xvjf $1 ;;</span><br><span class="line">        *.tgz)          tar xvzf $1 ;;</span><br><span class="line">        *.zip)          unzip $1 ;;</span><br><span class="line">        *.Z)            uncompress $1 ;;</span><br><span class="line">        *.7z)           7z x $1 ;;</span><br><span class="line">        *)              echo "don't know how to extract '$1'..." ;;</span><br><span class="line">       esac</span><br><span class="line">   else</span><br><span class="line">       echo "'$1' is not a valid file!"</span><br><span class="line">   fi</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>把上次执行的命令生成一个脚本</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo "!!" &gt; foo.sh</span><br></pre></td></tr></table></figure><ul><li>反向互补序列</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 'ATTGCTATGCTNNNT' |rev |tr 'ACTG' 'TGAC'</span><br></pre></td></tr></table></figure><ul><li>更工整的输出格式</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat file.txt | column -t |less -S</span><br><span class="line">csvtk pretty ### install csvtk</span><br></pre></td></tr></table></figure><ul><li>对samtools mpileup并行化call SNP</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BAM="yourFile.bam"</span><br><span class="line">REF="reference.fasta"</span><br><span class="line">samtools view -H $BAM </span><br><span class="line">    | grep "\@SQ" </span><br><span class="line">    | sed 's/^.*SN://g' </span><br><span class="line">    | cut -f 1 </span><br><span class="line">    | xargs -I &#123;&#125; -n 1 -P 24 sh -c "samtools mpileup -BQ0 -d 100000 -uf $REF -r \"&#123;&#125;\" $BAM </span><br><span class="line">    | bcftools call -cv &gt; \"&#123;&#125;\".vcf"</span><br></pre></td></tr></table></figure><ul><li>对多个tsv/csv表根据表头columns对行rows合并。类似于dplyr中的left_join()</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 合并col_names相同的表</span></span></span><br><span class="line">csvtk concat names.csv names.reorder.csv |csvtk pretty</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 忽略大小写，保留空的行，以"NA"表示</span></span></span><br><span class="line">csvtk concat names.csv names.with-unmatched-colname.csv -i -u NA | csvtk pretty</span><br></pre></td></tr></table></figure><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li>crazyhottommy/bioinformatics-one-liners(<a href="https://github.com/crazyhottommy/bioinformatics-one-liners" target="_blank" rel="noopener">https://github.com/crazyhottommy/bioinformatics-one-liners</a>)</li><li>stephenturner/oneliners(<a href="https://github.com/stephenturner/oneliners" target="_blank" rel="noopener">https://github.com/stephenturner/oneliners</a>)</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 脚本 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Daily-statistics_概率和似然</title>
      <link href="/2019/12/21/Daily-statistics-%E6%A6%82%E7%8E%87%E5%92%8C%E4%BC%BC%E7%84%B6/"/>
      <url>/2019/12/21/Daily-statistics-%E6%A6%82%E7%8E%87%E5%92%8C%E4%BC%BC%E7%84%B6/</url>
      
        <content type="html"><![CDATA[<h4 id="17-概率和似然-Probability-and-Likelihood"><a href="#17-概率和似然-Probability-and-Likelihood" class="headerlink" title="17. 概率和似然 Probability and Likelihood"></a>17. 概率和似然 Probability and Likelihood</h4><ol><li><p>概率就是在给定的分布情况下（固定不变fixed），一个区间内的面积即为此probability（变化的）。即 areas under a fixed distribution.<br><img src="https://cdn.jsdelivr.net/gh/wang-tianpeng/image_hosting/tianpeng_pic/20191207175856.png" alt="fig1"></p></li><li><p>在给定的数据分布点（fixed data points）下的可变化分布的Y轴值。即 y-axis values for fixed data points with distributions that can be moved.<br><img src="https://cdn.jsdelivr.net/gh/wang-tianpeng/image_hosting/tianpeng_pic/20191207180735.png" alt="fig2"></p></li></ol><h4 id="18-最大似然-Maximum-Likelihood"><a href="#18-最大似然-Maximum-Likelihood" class="headerlink" title="18. 最大似然 Maximum Likelihood"></a>18. 最大似然 Maximum Likelihood</h4><p>最大似然的目标是找到最能拟合数据分布的方法，例如已知的normal/Exponential/Gamma分布<br><img src="https://cdn.jsdelivr.net/gh/wang-tianpeng/image_hosting/tianpeng_pic/20191216220848.png" alt="fig3"><br>需要一个均值的位置点，能够最大化观测到测量重量的 似然值。均值的位置就是所有measurements的似然值能够最大。<strong>这就是估算平均值的最大似然</strong>。同理，找到能够最大化measurements的标准差的似然值。</p><h4 id="19-指数分布和其最大似然估计-The-exponential-distribution-and-its-Maximum-likelihood-estimate"><a href="#19-指数分布和其最大似然估计-The-exponential-distribution-and-its-Maximum-likelihood-estimate" class="headerlink" title="19. 指数分布和其最大似然估计(The exponential distribution and its Maximum likelihood estimate)"></a>19. 指数分布和其最大似然估计(The exponential distribution and its Maximum likelihood estimate)</h4><ol><li><p>Statistical distribution that models the time between events.(两个事件之间，时间的概率分布)</p><ul><li>一条短信收到后，再收到第二条短信的等待时间</li><li>一个视频被看过之后，下一个人再看这个视频中间所经过的时间。</li></ul></li><li><p>公式，及lambda推导的过程。在给定一组测量measurements，找到最佳的lambda，从而画出指数分布。<br><img src="https://cdn.jsdelivr.net/gh/wang-tianpeng/image_hosting/tianpeng_pic/20191219224331.png" alt="fig4"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> statistics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> StatQuest </tag>
            
            <tag> statistics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人网站+高效图床 搭建记录</title>
      <link href="/2019/12/20/%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99-%E9%AB%98%E6%95%88%E5%9B%BE%E5%BA%8A-%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"/>
      <url>/2019/12/20/%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99-%E9%AB%98%E6%95%88%E5%9B%BE%E5%BA%8A-%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考文章：使用 Github Pages 和 Hexo 搭建自己的独立博客(<a href="https://blog.csdn.net/qq_36759224/article/details/82121420" target="_blank" rel="noopener">https://blog.csdn.net/qq_36759224/article/details/82121420</a>)<br>Github+jsDelivr+PicGo打造稳定快速、高效免费图床(<a href="https://blog.csdn.net/qq_36759224/article/details/98058240" target="_blank" rel="noopener">https://blog.csdn.net/qq_36759224/article/details/98058240</a>)<br>hexo常用命令笔记(<a href="https://segmentfault.com/a/1190000002632530" target="_blank" rel="noopener">https://segmentfault.com/a/1190000002632530</a>)<br>Hexo 博客优化之实用功能添加系列(<a href="https://itrhx.blog.csdn.net/article/details/85010191" target="_blank" rel="noopener">https://itrhx.blog.csdn.net/article/details/85010191</a>)</p></blockquote><ol><li><p>安装node.js, Git</p></li><li><p>安装Hexo</p><ul><li>安装 hexo</li><li>安装 hexo 部署到 git page 的 deployer<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir Blog</span><br><span class="line">npm install hexo-cli -g</span><br><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Hexo初始化设置</p><ul><li>Hexo 安装完成后，将会在指定文件夹中新建所需要的文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir hexo</span><br><span class="line">hexo init</span><br></pre></td></tr></table></figure></li></ul></li><li><p>本地查看效果</p><ul><li><a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generate #g</span><br><span class="line">hexo server #s</span><br></pre></td></tr></table></figure></li></ul></li><li><p>博客部署到Github上</p><ul><li>创建 New repository</li><li>配置 SSH密钥，在Blog文件夹下</li><li>Github网站配置SSH密钥</li><li>配置Hexo的_config.yml文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;wangtianpeng1994@hotmail.com&quot;</span><br><span class="line">ssh -T git@github.com</span><br><span class="line"></span><br><span class="line">git config --global user.name &quot;wang-tianpeng&quot;</span><br><span class="line">git config --global user.email &quot;wangtianpeng1994@hotmail.com&quot;</span><br><span class="line"></span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https://github.com/wang-tianpeng/wang-tianpeng.github.io</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Hexo文件夹下启动转移至Github</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure></li><li><p>在<code>\hexo\source\_posts</code>文件夹下书写markdown文档</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">hexo n &quot;文章标题&quot;</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">layout: 页面布局（配合主题文档使用）</span><br><span class="line">title: 文章名称</span><br><span class="line">date: 文章日期</span><br><span class="line">comments: 文章是否开启评论</span><br><span class="line">photos: 文章封面图（仅部分主题支持）</span><br><span class="line">tags: </span><br><span class="line">  - 文章标签一</span><br><span class="line">  - 文章标签二</span><br><span class="line">categories: 文章分类</span><br><span class="line">description: 文章描述，即要在首页显示的摘要，而非全文显示。（仅部分主题支持）</span><br><span class="line">---</span><br></pre></td></tr></table></figure></li><li><p>配置Hexo的主题</p><ul><li>找到各种主题的Github页面</li><li>在theme文件夹下 git clone</li><li>在主文件夹下配置_config.yml文件</li><li>主文件夹下 hexo g s d</li><li>各种主题：<a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a></li><li>最终在挑选之后选择了<code>Yelee</code>主题<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/theme-next/hexo-theme-next</span><br><span class="line"></span><br><span class="line">theme: hexo-theme-next</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br><span class="line"></span><br><span class="line">hexo clean ## 清楚缓存</span><br><span class="line">hexo g -d</span><br></pre></td></tr></table></figure></li></ul></li><li><p>添加页面访问统计</p><ul><li>在<code>themes/你的主题/layout/_partial/footer.ejs</code>文件下添加以下代码即可</li><li>参考网站：不蒜子统计(<a href="http://ibruce.info/2015/04/04/busuanzi/" target="_blank" rel="noopener">http://ibruce.info/2015/04/04/busuanzi/</a>)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ol><ol start="10"><li>配置网络图床<ul><li>参考<a href="https://blog.csdn.net/qq_36759224/article/details/98058240" target="_blank" rel="noopener">Github+jsDelivr+PicGo</a></li><li>Github创建新仓库reporitory</li><li>Setting中设置新的token （注意不要关闭）repo项打勾</li><li>下载PicGO</li><li>配置成功后界面如下，可设置快捷键，截图+快捷键 自动操作。速度效率都十分不错，以后不再操心图床的问题。<br><img src="https://cdn.jsdelivr.net/gh/wang-tianpeng/image_hosting/tianpeng_pic/20191221144804.png" alt=""></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
            <tag> 图床 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Daily_statistics_置信区间+Pvalue+单尾双尾P值</title>
      <link href="/2019/12/16/Daily-statistics/"/>
      <url>/2019/12/16/Daily-statistics/</url>
      
        <content type="html"><![CDATA[<h4 id="15-置信区间-Confidence-Intervals"><a href="#15-置信区间-Confidence-Intervals" class="headerlink" title="15. 置信区间 Confidence Intervals"></a>15. 置信区间 Confidence Intervals</h4><ol><li><p>bootstrap是计算置信区间的一个方法。</p></li><li><p>95%的置信区间能够覆盖95%的均值（覆盖了95%的bootstrap过程中产生的均值intervals that covers 95% of means that you calculated when you bootstrap the sample）。</p></li><li><p>95%的置信区间意味着 在这个置信区间之外发生一次事件的概率Pvalue是小于0.05<br><img src="https://cdn.jsdelivr.net/gh/wang-tianpeng/image_hosting/tianpeng_pic/20191207173822.png" alt=""></p></li><li><p>比较两组随机样本。首先对这个随机样本取Bootstrap的均值，&gt;1000次，然后比较bootstrap后均值的置信区间。如果两个样本的95%置信区间不同，则两个样本是具有统计学差异的；而如果两个样本的置信区间之间有部分重叠，则需要做T-test检验。<br><img src="https://cdn.jsdelivr.net/gh/wang-tianpeng/image_hosting/tianpeng_pic/20191207174608.png" alt=""></p></li></ol><h4 id="16-P-value值"><a href="#16-P-value值" class="headerlink" title="16. P-value值"></a>16. P-value值</h4><ol><li>Pvalue并不是完全指概率值。Pvalue is the probability that random chance generated the data, or something else that is equal or rarer.就是<strong>双尾的概率之和</strong>。例如二项分布的抛硬币实验。两次抛掷都为头（heads）的Pvalue是0.25+0.25+0.<br><img src="https://cdn.jsdelivr.net/gh/wang-tianpeng/image_hosting/tianpeng_pic/20191214161150.png" alt=""></li><li>而抛硬币5次，对于4正1反的Pvalue值。包括4正1反，1反4正，以及5正/5反的概率之和<br><img src="https://cdn.jsdelivr.net/gh/wang-tianpeng/image_hosting/tianpeng_pic/20191214161929.png" alt=""></li><li>和概率有区别。Pvalue就是衡量这个值是否有特别之处。例如得到平均值的pr为0.01，但P-value=1。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Statistics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> StatQuest </tag>
            
            <tag> statistics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World!</title>
      <link href="/2019/11/27/Hello_World/"/>
      <url>/2019/11/27/Hello_World/</url>
      
        <content type="html"><![CDATA[<h3 id="title1"><a href="#title1" class="headerlink" title="title1"></a>title1</h3><h4 id="title-2"><a href="#title-2" class="headerlink" title="title 2"></a>title 2</h4><p><strong>bold text</strong><br><em>italy text</em></p><p><strong>New photo</strong><br><img src="https://cdn.jsdelivr.net/gh/wang-tianpeng/image_hosting/tianpeng_pic/ibcas.png" alt="test"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd</span><br><span class="line">ls</span><br><span class="line">ls -1 *.txt |xargs -i wc</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
